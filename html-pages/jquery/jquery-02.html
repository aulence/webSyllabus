<root data-root="jQuery选择器">
	<!-- jQuery选择器概述 -->
	<section class="mt0">
    	<h3>jQuery选择器概述</h3>
    	<p>jQuery的选择器实现的根源当然还是DOM，但对选择器简化的灵感来源却是CSS，jQuery发展到现在这个版本，CSS3能做到的，jQuery基本上都能做到（:before、:after除外），如：元素选择器，ID选择器、class选择器、属性选择器、结构选择器、状态选择器，UI伪元素选择器等等。不仅如此，jQuery还提供了一些CSS办不到，JavaScript+DOM也不能一句话搞定的选择器。如：文本包含选择器、标签包含选择器、包含元素筛选选择器等。</p>
    	<p>由于jQuery“诞生”的日子比较早（2006年），它的很多做法受到了其它各类库的效仿，当然jQuery也从其它库的身上“要来”不少东西，如火热一时的<em title="该库目前已经在朝着Web应用框架方向转型了">MooTools</em>。jQuery的设计模式刚出来的时候就收到业界的高度重视，在它诞生的第二年，其内容就成为很多计算机高校必修或选修的课程，这种情况就现在看来都是不可思议的。</p>
    	<p>选择器作为jQuery的核心内容，更是被很多JS库所效仿。甚至可以很不负责任的说，就连原生的JavaScript和DOM都深受其影响，如getElementsByClassName这个ECMAScript 2010（简称ES5）才出现的选择器，以及紧跟着出现的querySelector()和querySelectorAll()这两个像极了jQuery的DOM选择器。</p>
    	<p><em>Sizzle</em>是jQuery的开发者John Resig新编写的一个JavaScript选择器，速度号称业界第一。它在2009年1月14日的时候导入了jQuery的核心，使得jQuery更加的强大。该作者根据ES5及一些外来的灵感在2012年8月9日的时候发布了重写的Sizzle，这使得jQuery的性能更加强大。当然，Sizzle一直也作为独立的版本存在着，如果不想使用jQuery，也可以单独下载Sizzle，它的体积比jQuery要小得多。</p>
    	<p>和DOM选择器一样，jQuery的选择器参数部分是以字符串的形式存在的，所以允许变量或字符串与变量拼接的形式。如：</p>
    	<p>
<code class="ideCode-js">var ele;
$("#" + ele).text("元素文本内容");

var div1 = "div";
$(div1).html("div文本内容");
</code>
   		</p>
   		<p>&lt;关于jQuery课程中“代码显示器”（JS部分）中的代码颜色说明&gt;</p>
		<ul class="indent">
			<li>“<em>关键字</em>”代码颜色用<i class="diamond" style="background-color:#ff3f77"></i>色进行表示</li>
			<li>“<em>变量名</em>”代码颜色用<i class="diamond" style="background-color:#ee6aff"></i>色进行表示</li>
			<li>“<em>方法名</em>”代码颜色用<i class="diamond" style="background-color:#51ebff"></i>色进行表示</li>
			<li>“<em>字符串</em>”代码颜色用<i class="diamond" style="background-color:#ece077"></i>色进行表示</li>
			<li>“<em>代码注释</em>”代码颜色用<i class="diamond" style="background-color:#00d86c"></i>色进行表示</li>
			<li>“抽象词”或“特殊词”代码颜色用<i class="diamond" style="background-color:#87ff87"></i>色进行表示（“抽象词”就是用于概括表示某一类代码的词，并非真正的功能性代码，实际使用中需替换为正确格式的代码单词或字符串，而“特殊词”指有一定特殊含义的词）</li>
		</ul>
    </section>
    <!-- 元素选择器 -->
	<section>
    	<h3>元素选择器</h3>
    	<p>基本语法：</p>
    	<p>
<code class="ideCode-js">$(TagName).method(function() {
	// 需要做的事
});</code>
   		</p>
   		<p>示例中的“TagName”指的是标签名，在实际使用中记得加上引号。如果有多个标签名，可以用英文逗号进行分割，如例：</p>
   		<p>
<code class="ideCode-js">$("div,p,span").css("color", "#3d3d3d");</code>
   		</p>
   		<p>上例的实现的效果是，同时将div、p和span三个标签的字体颜色设置为“#3d3d3d”。</p>
   		<p>jQuery的元素选择器（标签选择器）和DOM的选择器产生作用的区别在于，jQuery选择器不需要给元素加上索引下标即可选中页面中所有的标签，而DOM需要通过一次循环来实现所有元素标签的选择遍历。其实jQuery的选择器也会进行一次内部的循环遍历，只不过这样的操作不需要开发者来进行了而已。</p>
    </section>
    <!-- ID选择器 -->
    <section>
    	<h3>ID选择器</h3>
		<p>基本语法：</p>
    	<p>
<code class="ideCode-js">$("#" + ID).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>和标签选择器一样，如果要对多个ID进行操作需要用英文逗号进行分割，如例：</p>
   		<p>
<code class="ideCode-js">$("#userName, #userPwd").val("");</code>
   		</p>
   		<p>上例的实现的效果是，将ID为“userName”和“userPwd”的输入框（只有表单元素才能使用val()方法）的值置空。ID是唯一的，所以不会对选择器进行遍历，若页面中存在多个同名ID，则只会选择第一个。所以，ID选择器无论是在JavaScript中还是在jQuery中，都是最快的一种选择器。但需要提醒的是，前端开发其实是应该尽量避免过多的ID出现的，特别是那些只是用于布局或视觉样式操作的ID更是没有必要了。这样只会带来名称管理的负担，ID无论在什么时候都应该体现出其唯一性的特点。</p>
    </section>
    <!-- Class选择器 -->
    <section>
    	<h3>Class选择器</h3>
		<p>又称“<em>类选择器</em>”，基本语法：</p>
    	<p>
<code class="ideCode-js">$("." + ID).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>和元素选择器、ID选择器一样，Class选择器也能同时一次性选择多个Class。</p>
   		<p>
<code class="ideCode-js">$(".mainNav, .leftName, .footerNav").css("text-decoration", "none");</code>
		</p>
   		<p>并且该选择器和元素选择器一样会在jQuery核心代码的内部执行一次循环将所有同名的Class都进行选择。</p>
    </section>
    <section>
    	<h3>属性选择器</h3>
		<p>和CSS一样，jQuery也能通过元素的属性进行选择。基本语法：</p>
   		<p>
<code class="ideCode-js">$([AttributeName]).method(function() {
	// 需要做的事
});</code>
		</p>
   		<p>当然，CSS选择器能做到的jQuery自然也不会含糊，如：</p>
   		<p>
<code class="ideCode-js">$("div[data-info]");
$("div[data-info='roleInfo']");
$("input[type='radio']");
$("img[title^='简约风...']");
$("input[placeholder*='请输入']");
// 等等...</code>
		</p>
   		<p>也就是说，只要CSS能使用的属性选择器，jQuery也能使用。只需要将CSS的选择器直接复制过来就能使用，当然，不要忘了jQuery的所有选择器都需要用一对引号括起来，变量例外，不过得保证变量也是一个字符串。</p>
    </section>
    <!-- 子元素和后代选择器 -->
    <section>
    	<h3>子元素和后代选择器</h3>
		<p>基本语法：</p>
		<p>
<code class="ideCode-js">// 子元素选择器
$(selector &gt; selector).method();
// 后代元素选择器
$(selector selector).method();

// 子元素选择器实例
$("div > p > a").click(function() {
	// 要处理的事件2
});
// 后代元素选择器实例
$("form input[type='radio']").focus(function() {
	// 要处理的事件1
});</code>
		</p>
		<p>这和我们平时使用CSS选择器也是一样的，而jQuery提供的后代选择器方法和子元素选择器方法则有所不同，它可以处理更多的未知性，并且有一定的查询作用。jQuery查询子元素主要提供两个方法：</p>
		<dl class="attrExplain">
			<dt>子元素查询children()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">// 子元素查询
$(selector).children(param);

// 查找form标签下的div下的全部input表单元素，并添加获得焦点事件
$("form div").children("input").focus(function() {
	// 需要处理的事件
});

// 将div下面所有标签的字体大小设置为16像素
$("div").children().css("font-size", "16px");
</code>
			</dd>
			<dd>该方法的参数是一个可选项，当不给参数的时候，它能选择当前元素下的“直接子元素”，这相当于是CSS里的“parent &gt; child”，不同的是CSS必须给出“child”的选择器名，而jQuery则不用。这个区别产生的实际意义就是，CSS必须指定某个子元素，而不能选择全部子元素，而jQuery可以指定某个子元素，也可以选择全部子元素</dd>

			<dt>后代元素查询find()</dt>
			<dd>基本语法</dd>
			<dd>
<code class="ideCode-js">// 子元素查询
$(selector).find(param);

// 查找header内是在单独窗口打开超链接的a标签，并添加一个类名newWin
$("header").find("a[target='_blank']").addClass("newWin");

// 将ul内所有li（可能存在列表嵌套）找出并添加点击后弹出当前li文本的功能
$("ul").find("li").click(function(){
	var liText = $(this).text();
	alert(liText);
});
</code>
			</dd>
			<dd>和children方法一样该方法的参数是一个可选项，当不给参数的时候，它能选择当前元素下的所有子元素，这相当于是CSS里的“parent child”，至于区别也和children方法与CSS之间是一样的。</dd>
			<dd>但这里需要特别说明，由于find方法会将当前元素的所有子元素节点都进行一次遍历，也就说当前元素子元素节点数量过大的话，带来的性能损耗是相当大的，有的时候宁愿连续用两次children方法都不要用一次find方法，从代码节点控制的严谨性上来讲，children方法也是要优于find方法的。</dd>
		</dl>
    </section>
    <section>
    	<h3>同级选择器</h3>
		<p>虽然CSS官方的翻译是“同级、同胞选择器”，但是我们知道无论是CSS里的“+”还是“~”选择符都只能选择器当前节点之后的同级元素。</p>
   		<p>选择当前元素相邻的下一个同级元素的jQuery选择器写法为：</p>
   		<p>
<code class="ideCode-js">$("li + li").method(param);</code>
		</p>
   		<p>而选择当前元素之后所有的同级元素的jQuery选择器写法为：</p>
   		<p>
<code class="ideCode-js">$("li ~ li").method(param);</code>
		</p>
   		<p>这和我们使用CSS的选择符进行元素的选择没有任何区别。但实际上，这两个选择符在jQuery里面是很少出现的，因为jQuery有更好的选择器同级元素的方法，而且性能表现上由于会省略掉正则判断一环，所以是一种更佳的选择器。</p>
   		<p>接下来我们就来介绍jQuery里的这些同级元素选择器。</p>
   		<dl class="attrExplain">
   			<dt>上一个同级元素prev()</dt>
   			<dd>基本语法：</dd>
   			<dd>
<code class="ideCode-js">$(selector).prev();</code>
   			</dd>
   			<dd>该方法不需要参数，因为这个方法能选到的元素节点是唯一的。如果找不到上一个元素节点，则会返回一个length为0的jQuery对象。没有办法使用现有的CSS选择器来实现该功能。</dd>

			<dt>下一个同级元素next()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).next();</code>
			</dd>
			<dd>该方法和prev()相比，只是选择的是当前元素的下一个元素节点，其它特性基本一致。</dd>

			<dt>之前的同级元素prevAll()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).prevAll(param);</code>
			</dd>
			<dd>该方法的参数为一个字符串，设置内容为CSS选择器，可选填。当参数为空的时候表示的当前元素之前所有的统计元素，当设置参数的时候必须是一个字符串或存有字符串的变量（可以使用变量+字符串的拼接操作），和jQuery选择器一样使用CSS选择器作为参数内容，这样就会返回当前元素之前指定选择器的节点。</dd>
			<dd>我们通过一个示例来理解该方法的功能，现有如下HTML代码：</dd>
			<dd>
<code class="ideCode-html">&lt;ul class="skill-list"&gt;
	&lt;li class="html"&gt;HTML&lt;/li&gt;
	&lt;li class="css"&gt;CSS&lt;/li&gt;
	&lt;li class="js"&gt;JavaScript&lt;/li&gt;
	&lt;li class="jq"&gt;jQuery&lt;/li&gt;
	&lt;li class="ng"&gt;Angular&lt;/li&gt;
	&lt;li class="rc"&gt;React&lt;/li&gt;
	&lt;li class="v"&gt;Vue&lt;/li&gt;
&lt;/ul&gt;</code>
			</dd>
			<dd>jQuery代码如下：</dd>
			<dd>
<code class="ideCode-js">// 点击列表项后使之前的列表项编程橙色
$(".skill-list > li").click(function() {
	$(this).prevAll().css("color", "#f80");
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-003.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-003.html" ></iframe>
			</dd>
			<dd>效果还是比较直观的，点击列表项的时候，当前项没有效果，当前项之前的列表项都会生效。现在我们为prevAll方法加上一个".css"选择器作为参数，这样无论点击class为“css”之后的哪一项，拥有“css”的项都会生效颜色变化代码。</dd>
			<dd>
<code class="ideCode-js">// 点击CSS之后的列表项，CSS项都会变成蓝色，而点击CSS或之前的项则不会有任何效果
$(".skill-list > li").click(function() {
	// prevAll方法内只能传入一个CSS选择器
	$(this).prevAll(".css").css("color", "#00f");
});</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-004.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-004.html" ></iframe>
			</dd>
			<dd>如果当前元素之前没有元素节点，则会返回一个length为0的jQuery对象。另外，还需要注意的一个小细节就是这类方法（后面出现的nextAll、prevUntil、nextUntil也是一样的）的匹配结果的顺序是从当前标签开始的一个“由近到远”的jQuery对象数组。例如，点击上例中的“jQuery”列表项并使用prevAll不带参数的遍历，出来的结果是“JavaScript → CSS → HTML”这样的顺序，了解这点，对我们以后实现一些复杂需求有思维上的帮助。</dd>

			<dt>之后的同级元素nextAll()</dt>
			<dd>基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).nextAll(param);</code>
			</dd>
			<dd>方法和prevAll()相比，只是选择的是当前元素之后的元素节点，其它特性基本一致。</dd>

			<dt>之前的第一个同级匹配元素prevUntil()</dt>
			<dd>该方法用于匹配当前元素之前一直到满足匹配条件之间（不包括这个元素）的同级元素，基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).prevUntil(param);</code>
			</dd>
			<dd>该方法的参数虽然是可选项，但总是建议传入参数，否则它和不带参数的prevAll方法几乎没有区别，也达不到我们使用它的目的。我们用这个方法来实现一个如下一个功能。</dd>
			<dd>HTML代码示例：</dd>
			<dd>
<code class="ideCode-html">&lt;main&gt;
	&lt;h3&gt;水果类&lt;/h3&gt;
	&lt;p&gt;苹果&lt;/p&gt;
	&lt;p&gt;梨子&lt;/p&gt;
	&lt;p&gt;香蕉&lt;/p&gt;
	&lt;p class="describe"&gt;补充维生素ABCDEFG&lt;/p&gt;
	&lt;h3&gt;零食类&lt;/h3&gt;
	&lt;p&gt;辣条&lt;/p&gt;
	&lt;p&gt;薯片&lt;/p&gt;
	&lt;p&gt;饼干&lt;/p&gt;
	&lt;p class="describe"&gt;杀死维生素ABCDEFG&lt;/p&gt;
	&lt;h3&gt;肉类&lt;/h3&gt;
	&lt;p&gt;牛肉&lt;/p&gt;
	&lt;p&gt;猪肉&lt;/p&gt;
	&lt;p&gt;羊肉&lt;/p&gt;
	&lt;p class="describe"&gt;补充蛋白质、能量、纤维素&lt;/p&gt;
&lt;/main&gt;</code>
			</dd>
			<dd>jQuery代码示例：</dd>
			<dd>
<code class="ideCode-js">// 点击当前p元素之后，一直到h3为止的元素都变成紫色
$("p").click(function() {
	$(this).prevUntil("h3").css("color","#f0f");
});
</code>
			</dd>
			<dd>
				<h4><a href="html-pages/jquery/codeEffect/code-005.html" target="_blank">运行效果</a>：</h4>
		<iframe data-iframe-coderun="" class="codeEffect" src="html-pages/jquery/codeEffect/code-005.html" ></iframe>
			</dd>
			<dt>后前的第一个同级匹配元素nextUntil()</dt>
			<dd>该方法用于匹配当前元素之后一直到满足匹配条件之间（不包括这个元素）的同级元素，基本语法：</dd>
			<dd>
<code class="ideCode-js">$(selector).nextUntil(param);</code>
			</dd>
			<dd>该方法和prevUntil特性完全一样，只是匹配的元素是从当前元素开始之后的元素而已。</dd>
			<dt>同级兄弟节点siblings()</dt>
    	</dl>
    </section>
    <!-- 父级选择器 -->
    <section>
    	<h3>父级选择器</h3>
		<p></p>
    </section>
    <!-- 奇偶选择器 -->
    <section>
    	<h3>奇偶选择器</h3>
		<p></p>
    </section>
    <!-- 结构性伪类选择器 -->
    <section>
    	<h3>结构性伪类选择器</h3>
		<p></p>
    </section>
    <!-- 状态选择器 -->
    <section>
    	<h3>状态选择器</h3>
		<p></p>
    </section>
    <!-- 表单元素选择器 -->
    <section>
    	<h3>表单元素选择器</h3>
		<p></p>
    </section>
    <!-- 索引选择器 -->
    <section>
    	<h3>索引选择器</h3>
		<p></p>
    </section>
    <!-- 动画元素选择器 -->
    <section>
    	<h3>动画元素选择器</h3>
		<p></p>
    </section>
    <!-- 哈希目标选择器 -->
    <section>
    	<h3>哈希目标选择器</h3>
		<p></p>
    </section>
    <!-- 文本包含选择器 -->
    <section>
    	<h3>文本包含选择器</h3>
		<p></p>
    </section>
    <!-- 标签包含选择器 -->
    <section>
    	<h3>标签包含选择器</h3>
		<p></p>
    </section>
    <!-- 包含元素筛选选择器 -->
    <section>
    	<h3>包含元素筛选选择器</h3>
		<p></p>
    </section>
    <!-- 空内容选择器 -->
    <section>
    	<h3>空内容选择器</h3>
		<p></p>
    </section>
</root>



