<root data-root="数据类型--内置对象">
    <!-- 数组详解 -->
    <section class="mt0">
        <h3>数组详解</h3>
        <p>数组是有序排列的一组值的集合，这些值被包含在一对方括号内，里面的这些值称作数组元素、数组项、数组成员等。每个数组内的值都会有一个“键名”，这些键名其实就是一个从0开始依次计数的下标，每个数组都会有一个“<em>length</em>”属性，表示数组元素的个数，所以数组内元素最大的下标值应该是“length - 1”。</p>
        <p>数组内的值可以是JavaScript允许的任何类型的值，甚至可以是数组自身，像这样数组内包含另外一个数组的数组被称作“二维数组”，如果数组内的数组任然继续包含数组，这样的数组就会形成“多维数组”。数组的基本表现形式如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-103.jpg">
        </code>
        <p>数组虽然有很多独立的特性，但它的数据类型仍然为对象型（object），它仍旧具有对象的诸多特点：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-104.jpg">
        </code>
        <p>在之前的JavaScript循环语句“for-in循环遍历”的一个章节中，我们讲到过，该循环语句能够遍历出一个对象的“键名”和“键值”，除此之外，我们还可以用“Object”的“<em>keys()</em>”属性方法去获取一个数组的“键名”，即元素下标：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-105.jpg">
        </code>
        <p>通过输出结果可以发现，该方法返回的结果仍旧是一个数组，但数组内的元素已经变成了数组元素下标的字符串。其实是因为JavaScript语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p>
        <p>像平时我们通过数组元素的下标来获取到的数组元素内容，诸如：arr[0]、arr[3]、arr[5]等，其实在程序内部已经被转换成了：arr[<em>"0"</em>]、arr[<em>"3"</em>]、arr[<em>"5"</em>]这样的形式。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-106.jpg">
        </code>
        <p>对于数组元素而言，它是可以先声明后赋值的，主要有两种声明方式：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-107.jpg">
        </code>
        <p>数组的赋值和普通变量的赋值有些区别，就是需要“对位赋值”，即通过数组元素下标对相应的位置进行赋值（哪怕这个位置在数组内还不存在）。这两种赋值语句我们都故意遗漏了数组元素下标[2]，即数组内的第3个元素，但是在产生的数组中却仍旧保留了这一个元素的位置，只不过它的值为undefined而已。在上面两种数组赋值语句当中，我们更推荐使用后一种。</p>
        <p>需要注意的是，数组虽然也是对象，但实际上下面这些获取数组元素的方法都是不合法的。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-108.jpg">
        </code>
        <p>JavaScript使用一个32位整数来保存数组的元素个数。这意味着，数组成员最多只有4294967295个（2<sup>32</sup> - 1）个，也就是说length属性的最大值就是4294967295。但在绝大多数的应用场景中，这样的数量已经足够了。另外，length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-109.jpg">
        </code>
        <p>通过上面的示例可以发现，数组中本来应该是5个元素。第一次获取到的数组长度也是5，当我们手动的将“length”属性的值赋成3之后，原来的数组成员从末尾开始减少了两个，变成了剩余的前3个数组元素。也就是说，对于数组而言“length”属性是“<em>可读写</em>”的<em>动态属性</em>。利用这一特性，我们可以达到一个删除数组元素的效果，也就是将“length”属性的值设置为0即可。同理，若一个数组中只有3个元素，这个时候将数“length”属性设置为5，那这个数组的第4位（下标[3]）和第5位（下标[4]）的值都将是undefined。</p>
        <p>对于设置数组的“length”属性需要明白的一个常识就是，该属性不能设置负数值，也不能设置大于2<sup>32</sup> - 1的值，更不能设置除数值型以外的值，否则程序会报错。</p>
        <p>检查某个键名是否存在的运算符<em>in</em>，适用于对象，也适用于数组。该运算符用于检测数组元素的某个位置是否存在元素，返回的是一个布尔值。当通过下标访问的这个位置的值为undefined或该位置不存在，那么它返回的值就为false，否则就为true。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-110.jpg">
        </code>
        <p>需要在这里进行补充说明的是，上例中下标为1和3的地方没有值，称作“<em>空位</em>（hole）”，它返回的值为undefined，但仍然会被计入数组的长度属性“length”中。而length的值是由数组中最后一个元素的下标+1决定的，我们看做这样一个实验来进行应证：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-111.jpg">
        </code>
        <p>针对这样的情况，需要进行一个额外的说明，就是“for-in循环遍历”和“Object.keys()”方法运行的原理都类似于一个单进程的指针，所以数组中的空位（即值为undefined的数组元素）都会被跳过，但通过“length”属性去进行“for循环”的时候，这些空位都不会被跳过。</p>
    </section>
    <!-- 数组操作 -->
    <section>
        <h3>数组操作</h3>
        <p>对于数组，之前我们已经谈到过，虽然它有自己的一套格式，也有自己一套独立的方法，但在JavaScript里，它仍然只是一个object的类型（可以通过类型判断输出方法typeof()得出），若要判断一个值是否为数组，可以使用“Array.isArray()”方法来进行判断，它的返回值是一个布尔值，true表示是一个数组，否者返回false。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-112.jpg">
        </code>
        <p>数组作为JavaScript的内置对象（这区别于包装对象），自然拥有一些自己的方法，有些方法是各类型的对象（包括包装对象）通用的，有些是它独有的，下面我们就来对它的这些方法进行讲解说明。</p>
        <dl class="attrExplain">
            <dt>valueOf()和toString()方法</dt>
            <dd>valueOf()方法用于返回对象本身的值，这是各种数据类型对象的通用方法，toString()方法可以将值转化成一个字符串，这和String()方法的作用是一样的，同样为一个通用的方法。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-113.jpg">
                </code>
            </dd>

            <dt>push()方法</dt>
            <dd>push()方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度，该方法会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-114.jpg">
                </code>
            </dd>
            <dd>这相当于：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-115.jpg">
                </code>
            </dd>
            <dd>但显然用push()方法的操作会安全一些，也更加的直观渐变，因为这样我们甚至不需要知道数组的“length”为多少，只要使用这个方法，新添加的数组元素都会出现在数组末尾，“length”属性也会随之变化。但在涉及到多个数组拼接的情况，使用concat()方法（使用该方法需要定义一个空数组作为临时变量）会更加简便一些，因为直接用push()方法，在参数内设置另外需要拼接的数组，得到的结果是原始数组包含了另外两个数组（不是拼接关系）。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-116.jpg">
                </code>
            </dd>
            <dd>如上例：愿意是要通过push()方法去拼接数组得一个完整的一维数组，但得到的却是一个二维数组。其实，数组的<em>原型类</em>内的push()方法内还内置了另外一个方法，就是“<em>apply()</em>”方法，使用方法如下例：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-117.jpg">
                </code>
            </dd>
            <dd>和使用concat()方法相比，这个方法一次只能拼接一个数组，也就是说该方法内只能接受两个参数，为两个需要进行拼接的数组，当写成上例中的第二种形式，参数内仍然需要包含自身，否则无法达到期望的结果，如下例。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-118.jpg">
                </code>
            </dd>
            <dd>另外，还有一定需要注意的是，和使用concat()方法相比，push()方法会改变原有数组，而concat()方法不会改变原有数组。</dd>

            <dt>pop()方法</dt>
            <dd>该方法的使用方式和push()基本一样，但它的作用是<em>删除</em>数组的<em>最后一个元素</em>，并返回该数组元素。也就是说该方法一次只能删除一个，不能删除多个，任何参数对于它来讲都是无效的，会被忽略。该方法同样会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-119.jpg">
                </code>
            </dd>

            <dt>shift()方法</dt>
            <dd>该方法的使用和pop()方法类似，它的作用是删除数组中的<em>第一个元素</em>，并返回该数组元素。仍然一次只能删除一个，参数对它无效。该方法同样会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-120.jpg">
                </code>
            </dd>

            <dt>unshift()方法</dt>
            <dd>该方法的使用和push()方法类似，它的作用是在数组的<em>开始位置插入</em>或<em>添加</em>（已有数组称插入，空数组称添加，）一个新的元素，并返回该数组长度。该方法同样会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-121.jpg">
                </code>
            </dd>

            <dt>reverse()方法</dt>
            <dd>该方法的作用是将已有数组倒序排列，并返回改变后的数组。该方法同样会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-122.jpg">
                </code>
            </dd>

            <dt>slice()方法</dt>
            <dd>该方法用于提取原数组的一部分，返回一个新数组，原数组不变。它的第一个参数为起始位置（从下标0开始），第二个参数为终止位置（不包括该位置）。如果省略第二个参数，则一直返回到原数组的最后一个成员。这和之前的字符串操作slice()方法非常类似。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-123.jpg">
                </code>
            </dd>
            <dd>除此之外，该方法还可以利用原型类中的“call()”方法将一个<em>类似数组</em>转化成真正的数组：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-124.jpg">
                </code>
            </dd>

            <dt>splice()方法</dt>
            <dd>该方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。该方法中的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-125.jpg">
                </code>
            </dd>
            <dd>另外，该方法的第一个参数可以为负数（但是第二个不能，因为它表示长度），表示从数组末端开始计数，开始计数的值为“-1”。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-126.jpg">
                </code>
            </dd>
            <dd>利用该方法的原理可以达到向指定位置插入数组元素的效果。第一个参数仍然是表示开始下标，第二个参数设为0，这样后续设置的参数就会出现在第一个参数下标位置之后：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-127.jpg">
                </code>
            </dd>
            <dd>以上例为参考，如果想插入多个元素，只需要在第3个参数后继续设置参数即可。</dd>
            <dd>和以往的数组操作一样，该方法同样可以省略第二个参数，这样一来删除的数组就会从给定的参数位置开始一直删除到末尾。通过获取该方法返回的值和原数组，达到了一个“分割”数组的目的。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-128.jpg">
                </code>
            </dd>

            <dt>sort()方法</dt>
            <dd>该方法对数组成员进行排序，默认是按照<em>ASC II</em>码顺序排序。排序后，原数组将被改变。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-129.jpg">
                </code>
            </dd>
            <dd>该方法通过和“reverse()”方法配合，可以实现一个简单的升序、降序排列的功能。但若要实现一个稍微复杂一点的排序，如对数组元素是对象的数组进行排序，这个方法能否办到呢，我们先来做这样一个尝试，让数组元素对象按照产品的价格进行排序。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-130.jpg">
                </code>
            </dd>
            <dd>通过访问元素组下标可以发现，素组内这三个对象的位置完全没有发生改变。其实要实现这个需求也是有办法的，就是需要给“sort()”方法配置一个函数作为参数来实现。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-131.jpg">
                </code>
            </dd>

            <dt>map()方法</dt>
            <dd>该方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。该方法不会改变原来的数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-132.jpg">
                </code>
            </dd>
            <dd>上例中，map()方法内有一个匿名函数，函数内有一个参数“ele”，这个参数的名称是自定义的（只要不是关键字和保留字），这个参数在函数运行的时候通过一次内部的遍历指向数组内对应的元素。我们可以通过在外部声明一个计数器变量来证明这一点。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-133.jpg">
                </code>
            </dd>
            <dd>通过上例可以发现，计数器的值由0变成了3，这说明该函数实际上在map()方法的内部执行了3次，而这个函数执行的次数正是由当前的数组元素的长度“length”属性决定的（也有特殊情况，后续会进行说明）。</dd>
            <dd>map()方法内的函数，最多可以接受3个参数。第1个，就是上面例子中出现的参数，它表示数组内每个元素的本身；第2个，表示数组内元素的下标位置；第3个，表示数组本身。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-134.jpg">
                </code>
            </dd>
            <dd>现在看到map()方法执行后返回的值可能会有些困惑，为什么会是[4,5,6]?那是因为push()方法在执行后返回的值是数组当前的长度（unshift()方法也是一样的），通过因为当前数组元素有3个，也就是说这个push()方法会在数组内被执行三次，三次运行后也分别返回了当前数组的长度，而这三次值的返回又组成了一个新的数组（当若这个数组没有用变量存储，或参与到某个表达式中是没有意义的）。而元素组却发生了改变，输出了6个数组元素长度的新数组。当然让这个数组发生改变的并不是map()方法，而是在该方法函数内的push()方法产生的效果（push()方法会改变原始数组）。</dd>
            <dd>该方法和“for-in遍历循环”语句有一个相似之处，即当数组元素中存在空位的时候，该函数是不会去执行的，但只要有明文的值，哪怕是遇到undefined、null、NaN等特殊的“无值”的值，该方法仍然能够执行。我们来看这样一个例子就明白了。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-135.jpg">
                </code>
            </dd>

            <dt>forEach()方法</dt>
            <dd>该方法与map()方法很相似，也是遍历数组的所有成员元素，执行某种操作，但是forEach()方法一般不返回值，只用来操作数据。如果需要有返回值，一般使用map()方法。forEach()方法的参数与map()方法一致，也是一个函数，数组的所有元素会依次执行该函数。它接受三个参数，分别是当前位置的值、当前位置的下标和整个数组。</dd>
            <dd>forEach()方法的参数与map()方法一致，也是一个函数，数组的所有成员元素会依次执行该函数。它接受三个参数，分别是当前位置的元素值、当前位置的下标和整个数组。函数内三个参数的使用方法和map()基本上一致，我们先举例一个函数内只带一个参数的情况。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-136.jpg">
                </code>
            </dd>
            <dd>上例中函数内的“console.log()”方法得到执行，但关键字“return”后续的内容却没有生效，说明forEach()方法是不会执行返回值操作的。另外，该方法可以有第二个参数（并不是值函数内部的参数，而是指forEach()方法本身的参数），第二个参数用于“告诉”函数内部的“this”关键字的指向。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-137.jpg">
                </code>
            </dd>

            <dt>filter()方法</dt>
            <dd>从方法名来看该方法的主要作用是<em>过滤</em>，它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-138.jpg">
                </code>
            </dd>
            <dd>和之前的map()和forEach()方法一样，该方法的函数仍旧支持3个参数，参数位和之前的这两个方法也是一样的，分别表示：数组元素、元素下标和原数组。但要同时使用三个函数内参数的例子并不好举，这里先通过一个抽象的例子来表示用法，实际开发中可以根据需要灵活选取。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-139.jpg">
                </code>
            </dd>

            <dt>some()和every()方法</dt>
            <dd>这两个方法用来判断数组成员是否符合某种条件。它们接受一个函数作为参数，所有数组成员元素依次执行该函数，返回一个布尔值。它们的函数接受三个参数，依次是数组元素、元素下标和原数组。</dd>
            <dd>some()方法是只要有一个数组成员的返回值是true，则整个some()方法的返回值就是true，否则返回false。这理解起来和逻辑运算符或“||”比较相似。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-140.jpg">
                </code>
            </dd>
            <dd>和every()方法是只要有一个数组成员的返回值是false，和every()方法的返回值就是false，否则返回true。这理解起来和逻辑运算符与“&amp;&amp;”比较相似。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-141.jpg">
                </code>
            </dd>

            <dt>reduce()和reduceRight()方法</dt>
            <dd>这两个方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce()方法是从左到右处理，reduceRight()方法则是从右到左，其他完全一样。它们支持最多四个参数，前两个参数是必需配置的，后面的参数可以选配，它们的作用如下：</dd>
            <dd>
                <ul>
                    <li>累积变量，默认为数组当前的第一个数组元素</li>
                    <li>当前变量，默认为数组当前的第二个数组元素</li>
                    <li>当前数组元素的下标位置</li>
                    <li>原数组</li>
                </ul>
            </dd>
            <dd>由于这两个方法的原理完全一样，只是方向不同，所以这里我们暂时只拿reduce()举例：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-142.jpg">
                </code>
            </dd>
            <dd>简单地从参数和返回的表达式来看，可能一时无法看透该方法的运行原理，我们再拿一个简单的例子来分析说明：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-143.jpg">
                </code>
            </dd>
            <dd>这两个方法一般在做数据统计的时候比较常用，通常用来统计如“总成绩”、“总收入/支出”或“积分”等内容。如果，在某个页面/应用内该方法会大量使用，这个时候就可以通过数组的原型类把它封装成一个方法，以供随时调用。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-144.jpg">
                </code>
            </dd>
            <dd>数组的原型类方法内部有个关键字“this”，和我们之前讲到前几个方法一样，它们都可以拥有第二个参数，用于限定this指向的对象。这里的this的作用就是，谁调用该方法，这个this就指向谁。如上例：“income”数组在调用方法“tatal()”时，this就是指“income”。“expend”数组在调用方法“tatal()”时，this就是指“expend”。</dd>
            <dd>通过原型类定义的一个方法，和直接用关键字“function”创建的函数的一个显著区别在于，原型类的参数在原型内就已经定义好，只要了解其功能，就可以在多处地方任意使用，而function需要根据使用场景不同配置不同的参数。所以相对function来说原型类在使用的时候的简便性和易用性都会高上一些。</dd>

            <dt>indexOf()和lastIndexOf()方法</dt>
            <dd>indexOf()方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。该方法和字符串中的indexOf()方法基本类似。</dd>
            <dd>lastIndexOf()方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。该方法和字符串中的indexOf()方法基本类似。</dd>
            <dd>这两个方法执行的原理完全一样，只是方向不一样，所以这里我们就只以indexOf()方法举例。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-145.jpg">
                </code>
            </dd>
            <dd>根据方法的执行原理，若要使用在条件判断语句内需要判断的值需要注意，不是数值0，也不是布尔值true或false，而是数值“-1”。</dd>
            <dd>另外，这两个方法还能配置第二个参数，表示开始检索的位置。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-146.jpg">
                </code>
            </dd>

            <dt>链式使用</dt>
            <dd>在数组的方法中，除了可以实现数组操作方法的嵌套，若所用方法返回的仍旧是一个数组的话，还可以使用<em>方法链</em>来完成一个特定的功能。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-147.jpg">
                </code>
            </dd>
            <dd>在有一些需求复杂的程序中，我们很难通过一个简单的数组操作方法去完成一项特定的功能，只有通过这些数组的一个个操作才能完成指定需求。但若每个返回结果都用一个变量去存储，声明很多变量，不仅代码可阅读性有所降低，程序的性能降低，需要大量的命名有的时候也是一个麻烦。这个时候，如果熟悉每种数组操作的返回结果，通过链式的方法去执行数组操作，那对于代码的优化来讲将是一个不错的帮助。</dd>
        </dl>
    </section>
    <!-- 章节练习 -->
    <section class="unitPractice">
        <h3>&lt;章节练习一&gt;</h3>
        <p>通过链式数组操作语法，完成有以下班级成绩数组的显示需求：</p>
        <p>[48,63,55,92,96,77,82,69,86,83,16,72,90,81,88,80,73,66]</p>
        <p>1、成绩需要由高到低排列；</p>
        <p>2、需要及格（包括60分）到90分以下（不包括90分）的区段的成绩；</p>
        <p>3、获取到及格到90分以下区段分数的总成绩。</p>
    </section>
    <!-- 对象详解 -->
    <section>
        <h3>对象详解</h3>
        <p>对象（object）是JavaScript的核心概念，也是最重要的数据类型。JavaScript的所有数据都可以被视为对象。简单说，所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value，亦称属性名值对、成员等）构成。下面展示了两种对象的书写方法：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-148.jpg">
        </code>
        <p>两种写法的引号可为双引号，也可以为单引号。若有多个键值对，每个键值对后面都需要加上英文逗号“,”作为分割符，否则程序会报错，最后一个键值对后方可加，也可不加。第一种写法为常用写法，是程序中最常用的写法，第二种写法叫做严格写法，这种严格模式的写法通常用于<em>JSON</em>文件的编写。但实际上第二种写法在某些情况下是一种必要手段，就是当属性名（键名）为数字外加其它内容等一些非严格命名模式的时候。如果为数字（包括科学计数法、浮点数、进制数），数字会被自动转换成字符串，如果是出现数字+其它字母、字母+空格+字母、字母+其它符号等的时候，就必须要手动加上引号了，否则程序会报错。 </p>
        <code class="indent">
            <img src="img/code/jscode/code-js-149.jpg">
        </code>
        <p>其实哪怕就是从我们编辑器（示例采用编辑器为“Adobe Brackets”）的代码颜色来看，第二种写法也明显不符合语法规范，键名出现了颜色不正常的现象，放置于控制台运行，可以更加清晰地看到运行的结果。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-150.jpg">
        </code>
        <p>另外，JavaScript内的关键字和保留字也可以作为属性名，并且不需要加上引号也能正常使用。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-151.jpg">
        </code>
        <p>对象允许的值可以是JavaScript种的任何类型（6种类型），可以是一个表达式，也可以为一个函数，当一个属性的值为一个函数的时候，通常把这个对象的属性称作“方法”（如操作字符串或数组的各种方法），它可以像使用其它对象内的属性一样使用，但是需要在后方加上一对括号。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-152.jpg">
        </code>
        <p>定义了这样一个包含了对象之后，就可以在程序中使用了（作用域仍然只分全局和函数的作用域）。为了直观展现运行结果，我们依次对上面定义的这个对象的各个属性在控制台运行程序后进行访问或使用。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-153.jpg">
        </code>
        <p>可以发现，我们现在对象中定义属性直接可以被像一个变量一样使用了，只不过是使用的时候多了一个点“.”，将普通变量的“=”号换成了“:”号而已，除此之外基本没有任何不同。</p>
        <p>当然，和作为数组形式展现的对象一样，普通对象也可以先声明再设置属性。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-154.jpg">
        </code>
        <p>根据对象的这个特性，我们就可以根据当前的使用场景（如满足一定的条件语句后），动态地为对象添加需要的属性了。但需要注意的是，对象数据类型是引用型数据，也就是说当一个对象赋值给另外一个变量后，它们指向的内存地址是相同的（这和数组一样），如例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-155.jpg">
        </code>
        <p>但是有一点需要注意，也就是任何一个对象取消对值的引用，之前已经引用过该值的对象是的值仍旧会保留。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-156.jpg">
        </code>
        <p>对于对象属性的读取，主要有两种方式，一种是“对象.属性”的格式，另一种是“对象[属性]”的格式。但是这两种方法在有些情况下并非等价的，就是如果属性是<em>数值型</em>的话不能采用第一种加“.”的形式，只能写成第二种形式。如果属性是<em>字符串</em>的话，两种形式都可以使用，但是使用第二种的话需要再在方括号内加上一对引号，否则会被视作一个变量。正确示例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-157.jpg">
        </code>
        <p>错误示例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-158.jpg">
        </code>
        <p>这两种访问属性的方法的区别还不止于此，通过“.”访问的属性不能是变量，不能是运算表达式，但是用“[attr]”这种方式可以接受变量，亦可以接受运算表达式。在对象的属性不是很确定的时候，用“[variable]”作为一个对象的载体是一个非常不错的选择。</p>
        <p>比如现在，我们在一个虚拟出来的“书籍”对象内配置一个简单的方法，用于输出一个对象内指定属性的值，就可以这样去写：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-159.jpg">
        </code>
        <p>在控制台中进行传参调用后的结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-160.jpg">
        </code>
        <p>如果讲上例中的“book[link]”换成“book.link”的话，该功能是无法完成的，无论配置任何参数返回的都将是undefined。正是因为使用“[]”的形式有接收变量的作用，这为我们以后封装具有对象的函数提供了便利。但若所使用对象不涉及到变量，还是建议使用“.”的形式对属性访问更加便捷高效。</p>
        <p>对于使用“[]”访问对象的属性还有一点需要补充，就是若对象是一个数组的话还可以使用<em>运算表达式</em>去访问数组内的内容。这对于实现一些复杂的需求会有一定程度的帮助，我们看来这几个简单例子：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-161.jpg">
        </code>
        <p>示例中最后三个完全一样的表达式“arr[Math.round(Math.random() * (arr.length - 1))]”得出的结果却不相同，是因为里面用到了<em>Math</em>函数内的取0~1之间的随机数方法<em>random()</em>，外层用该函数的“四舍五入”方法<em>round()</em>保证取出的数是整数。整个“[]”取出的数为整个数组下标从0到length-1（最大下标）之间的随机下标。</p>
        <p>和查看所有数组的下标一样，利用<em>Object.keys(obj)</em>方法可以查看对象所有的属性名，返回的结果是一个数组。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-162.jpg">
        </code>
        <p>通过上面的示例可以发现，利用这个内置对象Object的keys()方法，我们可以“玩出”非常多的花样，不仅可以像数组那样通过“length”属性（对象本身是没有length这个属性的）获取到对象的属性个数，还可以像数组那样，通过下标去访问对象内的属性值。单是获取对象属性个数这一点来讲，这个方法会被我们用“计数器”+“for-in遍历”要显得“干净”得多。</p>
        <p>对于数据操作来讲，无非就是四种操作“增、删、改、查”。对于对象来讲，“增”就是为一个对象新增一个之前不存在的属性名，然后进行赋值；“改”就是对对象已经存在的属性名进行从新赋值，达到一个修改原始对象的效果；而“查”就是简单地通过对象的属性名访问即可（当然也可以通过对“[]”传变量实现访问）。这些我们之前都讲解过，但对于“<em>删</em>”来讲稍微有些特殊，需要用到关键字“<em>delete</em>”进行操作，为了说明问题，我们还是对这些操作进行回顾并在其中列出“delete”的使用方式。原数组如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-163.jpg">
        </code>
        <dl class="attrExplain">
            <dt>增</dt>
            <dd>新增一个“出版社”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-164.jpg">
                </code>
            </dd>

            <dt>删</dt>
            <dd>删除“出版装订类型”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-165.jpg">
                </code>
            </dd>
            <dd>注意，该方法在执行成功后会返回一个布尔值<em>true</em>，只有当正在删除的对象属性不存在或不能删除（如继承的属性：toString、valueOf等）时才会返回false值。</dd>

            <dt>改</dt>
            <dd>修改“图书页数”和“出版时间”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-166.jpg">
                </code>
            </dd>

            <dt>查</dt>
            <dd>查询“书名”、“作者”和“页数”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-167.jpg">
                </code>
            </dd>
        </dl>
        <p>当不知一个对象的属性是否声明过，使用<em>in</em>运算符来进行判断是再好不过的选择了（选用对象仍是之前的“书籍”）。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-168.jpg">
        </code>
    </section>
    <!-- 对象操作 -->
    <section>
        <h3>对象操作</h3>
        <p>JavaScript原生提供一个Object对象，所有其他对象都继承自这个对象。Object本身也是一个构造函数，可以直接通过它来生成新对象。基本语法为：</p>
        <p><em>var obj = new Object();</em></p>
        <p>对象型数据有一个比较有趣的特点就是它具有<em>原型类</em>（prototype），任何对象都能通过原型类来拓展自己的功能，这一点，我们在“数组操作”一节中的“数组求和”功能里就已经见识到了。数组之所以可以通过原型类来扩展自己的功能，是因为数组本身也属于“对象”。我们再来看一个关于内置对象通过原型类扩展自己的<em>方法</em>的简单例子，基本代码如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-169.jpg">
        </code>
        <p>在控制台中被调用后的返回值结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-170.jpg">
        </code>
        <p>上面的代码中，首先是给内置对象Object添加了一个原型类的方法，该方法内“keys()”方法的作用我们在上一节“对象详解”中已经学习过，是用于讲对象的属性名进行返回，然后形成一个数组。而在该方法之前有一个关键字<em>this</em>，它表示使用该原型方法的对象的本身，如“obj1”在使用“showAttr()”方法时，“this”指的就是“obj1”。</p>
        <p>showAttr()这个方法是我们的一个自定义名称，我们可以根据需要，给原型类添加任意的自定义方法。这样一来，以后所有的新建对象都可以使用这些方法，大大地减少了代码量和也减少了对方法参数的配置。可以把原型类内我们自定义新建的方法理解为对象的公共方法，任何对象在同一个作用域内都可以对其进行使用。</p>
        <p>其实，也并非只有数组（Array）和普通对象（Object）才是所谓的“对象”，可以将JavaScript任何允许的数据类型放置于<em>Object()</em>方法的参数内都可以转换成为一个对象，这样的对象称作“<em title="变量的赋值操作是对值的引用">包装对象</em>”，这在我们上一章的课程内。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-171.jpg">
        </code>
        <p>但如果，使用Object()方法为参数内配置一个JavaScript的“<em title="变量的赋值操作是对内存地址的引用">内置对象</em>”，那返回的就是该对象本身。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-172.jpg">
        </code>
        <p>为了证明这一点，我们对刚才的这些内置对象做了一次“严格等于”运算符的比较运算。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-173.jpg">
        </code>
        <p>像“对象”这种复合型的值，通过普通方式来判断它是否为一个“内置对象”比较困难，像判断数值和判断数组都有类似于“isNaN()”和“isArray()”这样的方法，但是对象却没有，直接使用我们猜测存在的方法“isObject()”只会是这种下场：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-174.jpg">
        </code>
        <p>但好消息是，这并不妨碍我们自己根据对象已经暴露的一些特性给它创建一个“原生方法”：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-175.jpg">
        </code>
        <p>调用我们自定义的原型类方法后，在控制台中的返回值结果分别如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-176.jpg">
        </code>
        <p>上一章我们在讲解“字符串操作”的时候提到过一个方法“<em>String()</em>”，它可以将任何类型的数据都转换成字符串，但在转换数组和对象时，出现了点特殊情况（可以自行回顾该章节的内容），即其它类型的数据都变成了和原始声明时基本一样的数据，只是加上了引号，而对象出现的结果却是“<em>[object Object]</em>”，其实这里的第一个值表示该值是一个对象（之前提到过，JavaScript中任何值都可以成为对象），第二个值为该类型值的构造函数（有些对象是通过包装而来的）。当然，除了将需要转换字符串的内容放置于String()方法的参数内，还能通过对象属性的方式来使用该方法，它的写法是“toString()”，不需要配置参数。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-177.jpg">
        </code>
        <p>可以从运行结果中看出来，这和我们上次使用的“String()”方法得出的结果完全一样。但其实作为一个对象的属性的“toString()”方法来讲自然会有一些不同的。它其实是对象原型类的一个方法，语法如下：</p>
        <p><em>Object.prototype.toString</em></p>
        <p>既然是原型类的方法，那很多时候它们还有自己的“<em title="内部的实现相当于一个函数闭包">子方法</em>”，如“<em>call()</em>”方法。基本使用方法如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-178.jpg">
        </code>
        <p>通过示例可以发现，除了特殊的自身不等于自身的“NaN”值以外，其它的值都在返回结果的第二个值中表现出了自己真实的“值类型”，这最大程度地弥补了“typeof()”方法（通常情况下，typeof()方法还是首选）的不足。但是单是发现了这个原型方法的特性还没有什么用，要真正地将该特性利用起来，还得我们自己写成一个方法函数。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-179.jpg">
        </code>
        <p>通过在控制台中调用该函数进行测试：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-180.jpg">
        </code>
        <p>经过简单测试，自定义的方法完美地实现了数组类型的精确判定。另外，上例中出现了一个陌生的方法啊，已经在注释内进行说明了，就是将英文转换成<em>小写字母</em>的方法“<em>toLowerCase()</em>”，和将英文转换为<em>大写字母</em>的方法“<em>toUpperCase()</em>”，但这在中文网站或应用内并不常用，只需明白有这两个方法（实际上还有个每个单词首字符都大写的方法），需要使用时再进行查询即可。</p>
        <p>明白了这些特性后，我们还可以发挥自己的想象能力玩一些更为“高端的操作”，如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-181.jpg">
        </code>
        <p>通过在控制台中调用自定义的对象的方法进行测试：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-182.jpg">
        </code>
    </section>
    <!-- 章节练习 -->
    <section class="unitPractice">
        <h3>&lt;章节练习二&gt;</h3>
        <p>通过已经学习过的方法完成以下数组和对象的“克隆”，克隆后的数组和对象的值发生改变后，对原数组和对象的值不产生影响：</p>
        <p>1、数组：["HTML","CSS","JavaScript"]；</p>
        <p>2、对象：{name: "JS", fullName: "JavaScript", duty: "行为控制"}</p>
    </section>
    <!-- 函数详解 -->
    <section>
        <h3>函数详解</h3>
        <p>所谓“函数”，就是使用关键字“<em>function</em>”定义的一段有<em>独立作用域</em>，能被<em>反复执行</em>的语句块。它在JavaScript中也是以一种“值”的方式存在的（JS允许的六种数据类型之一），和其它数据类型相比，它是一种可以接收“<em>参数</em>”的，可运行的值，除此之外，它并没有任何的不同。</p>
        <p>但JavaScript作为一个“面向对象”和“函数式编程”的语言，“函数”部分自然是一个重点，而且也有一些区别于其它语言，即可以称为特色的地方。接下来我们就对JS中的“函数”进行详细的学习。</p>
        <p>首先，要提到的就是函数的声明方式，主要有四种：</p>
        <dl class="attrExplain">
            <dt>利用关键字“function”声明</dt>
            <dd>基本语法格式为：<em>function fnName(param list) {...}</em></dd>
            <dd>function关键字后空格紧跟一个自定义的<em>函数名</em>，该名称的命名方式、要求与变量的命名方式、要求基本一致（即避免出现特殊符号，不使用关键字、保留字，名称开头不使用数字等），名称后发紧跟一对小括号“<em>()</em>”，小括号内部可以根据需求配置一个或多个<em>参数</em>，小括号后方又得跟一对花括号“<em>{}</em>”花括号，函数内所有的语句都需要放置于该花括号内部。</dd>

            <dt>利用函数表达式进行赋值声明</dt>
            <dd>基本语法格式为：<em>var fnName = function(param list) {...};</em></dd>
            <dd>这种函数的声明方式是将函数当做了一个表达式，然后将表达式赋给了函数名，这和“var num = 2 + 3;”、“var str = "这是第" + num + "行字符串";”等这些表达式并没有什么不同。</dd>
            <dd>但通过表达式声明的函数需要注意两点。第一点，这样声明的函数，需要先声明后调用，否则像上面的函数名的值将为undefined;第二点，表达式内部的function后方不需要再空格+函数名了，如果这样写，function后方的函数名只能被函数内部调用，在外部是无法使用的，如例：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-183.jpg">
                </code>
            </dd>
            <dd>除了上述需要注意的两点外，这种方式声明的函数和利用funciton关键字定义的函数并没有什么区别。</dd>

            <dt>利用构造函数“Function”声明</dt>
            <dd>基本语法格式为：<em>var fnName = new Function(param list, ...);</em></dd>
            <dd>这种写法是将参数列表和函数体放置在了一起同样作为了参数。构造函数内的参数无论有多少个，始终会将其最后一个参数作为函数体去执行，如果只有一个参数，那这个参数就是函数体内部的代码。但使用这种方式需要注意的是，就算是参数和函数体的语句也是要作为字符串去呈现的，即需要给参数和函数体执行的代码都加上引号，否则会报“未定义”的错误。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-184.jpg">
                </code>
            </dd>
            <dd>这种将参数和函数体内的语句糅杂在一起的写法非常不直观，实际开发中并不推荐使用。</dd>

            <dt>自调用函数（即时执行函数）</dt>
            <dd>基本语法格式为：<em>(function() {...})(param);</em></dd>
            <dd>这种函数声明方式的最大特点是“即时性”。它不需要任何调用，即可立即执行。它可以有函数名，通常也可无函数名。它执行的原理是利用小括号将函数自身括起来，以到达提升括号内函数表达式优先级的作用，括号内部的函数生效后，又紧接着后面的括号进行函数的调用，从而实现自我调用的效果。如下例：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-222.jpg">
                </code>
            </dd>
            <dd>这种函数的声明方式和其它函数的声明方式一样，它仍然有自己的独立<em>作用域</em>。自调用函数还有一个特点就是，它的运行虽然还是在程序的<em>独立线程</em>完成的，但是却可以达到程序在<em>主线程</em>完成的效果。（这一点在“函数的作用域”一节中进行讲解）</dd>
        </dl>
        <p>每一个函数都会有一个返回值，这个返回值可以通过关键字“<em>return</em>”进行设置，若未<em title="编程技术中的术语，相对于“隐式”">显示</em>地设置函数的返回值，那函数会默认返回一个<em>undefined</em>值。如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-216.jpg">
        </code>
        <p>但若手动地设置了函数的返回值，即手动地设置了关键字“return”空格之后的值后，函数将不再会返回undefined了，而是返回开发者手动设置的那个值：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-217.jpg">
        </code>
        <p>上例中，通过手动设置了关键字return之后的值后，undefined就没有再出现了。但在手动设置函数返回值的时候需要注意的一点就是，代码一旦执行完成“return”这行语句后，代码就会跳出整个函数，即不再执行当前函数的后续语句，这一点可以善加利用，特别是在一些条件语句内部使用。如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-218.jpg">
        </code>
        <p>根据上例返回的结果可以发现，函数“fn()”内的控制台输出“4”和“5”并没有执行，是因为代码执行return之后，该函数也就结束了，函数执行完后，还是会依次执行之后的语句。但在这里还需要补充一点，就是“return”之后的值只能有一个。如果尝试返回多个值，那得到的结果始终是最后一个值：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-219.jpg">
        </code>
        <p>在有的使用场景中，如果真的需要函数返回多个值，那就只有将值组合成一个对象进行返回了，然后再通过访问函数的属性去获取返回的具体值，如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-220.jpg">
        </code>
        <p>也可以改成这种形式：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-221.jpg">
        </code>
        <p>和声明和一个变量一样，在同一个作用域内，若函数重复声明，后声明的函数会覆盖之前声明过的函数，使之前声明过的任何同名函数无效。所以在大型网站/应用中，声明函数也应该要有和命名变量那样的“命名空间”的思维，即将函数当做对象中的一个方法那样去使用。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-185.jpg">
        </code>
        <p>上面的函数改成“对象”的方法后再次执行，表现和结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-186.jpg">
        </code>
        <p>这样写虽然在很大程度上避免了函数名的重名，从而导致部分函数无效的情况。但需要提醒的是，只要是通过表达式赋值声明的方式都会面对一个问题，就是声明和调用的次序问题。我们来看几个例子：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-187.jpg">
        </code>
        <p>通过上例可以发现，通过函数表达式的方式声明的函数，在先调用和声明的时候报错了。当然这种后声明不管是通过一个变量声明还是通过一个对象内的属性声明，结果都是一样的，会报错。所以，在大型网站/应用中需要使用对象方法来定义一个函数的，但又不希望将所有函数都放置于JS文件开头（这样一来所有的事件和事件处理的逻辑都得放置于JS文件的后方，实际操作起来非常不方便），可以使用JS提供的一个事件“<em>window.onload = function() {...加载执行完成后的事件...}</em>”，这个事件的作用是保证页面所有文档（包括图片）都加载完成之后执行的代码，或使用jQuery中的“$(document).ready(function() {...加载执行完成后的事件...})”（简写为：“$(function(...加载执行完成后的事件...) {...})”）,这个事件的作用是保证页面所有文档（不包括图片）加载完成后执行的代码。</p>
        <p>我们通过一个这样的示例就明白了：（由于涉及到“事件的调用”，我们的代码编写部分在编辑器内进行）</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-188.jpg">
        </code>
        <p>在控制台中运行的结果就是：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-189.jpg">
        </code>
        <p>但若将外层的事件“window.onload”去掉之后，程序就会报错了，会告诉你函数“fnExp_1”和“fnExp_2”未定义。但千万不要认为将函数定义在程序后面会有这么多麻烦就放弃使用这种方式了。其实将函数定义在后面，而在代码的前面进行调用有诸多好处。其中一点，就是可以让您的代码像一本书一样具有“目录”（前提是有良好的注释），可以通过简单的事件方便地查找到函数的原始定义部分（现在绝大多数的编辑器都提供类似于“跳转到函数定义部分”的功能），让开发者在维护代码的时候更加清晰地认识所定义的函数在代码中所起的作用。</p>
        <p>函数可以在页面中的任何地方声明定义，但根据ECMAScript的规范，函数是不能在条件语句内声明的，这点在使用的过程中需要特别注意。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-206.jpg">
        </code>
        <p>如果实在是要这么做，只有使用函数表达式的声明方式去进行从定义。需要注意的就是，如果是要在条件语句内修改函数，那需要保证原函数和条件语句内的函数都是通过表达式的方式声明定义的，否则程序仍然会报错。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-207.jpg">
        </code>
    </section>
    <!-- 函数的参数 -->
    <section>
        <h3>函数的参数</h3>
        <p>在很早之前我们就接触过了函数的<em>参数</em>，它是让函数<em>可复用</em>的关键性存在。就是当程序里很多地方都在做着同样一件事件，但只是部分需要呈现的内容不同的时候，我们就可以使用配置参数的形式来完成一个函数的功能。如在学习JavaScript之初，我们就会接触到的“<em>alert()</em>”函数和“console.log()”方法一样，我们只需要在使用它们的时候往该函数或方法的括号内添加我们需要显示的内容即可让它实现其功能。我们在往括号里添加显示内容的这一个过程就叫做“配置参数”（亦作“传入参数”、“提供参数”等），而对于JavaScript设计这些方法的时候为其括号内添加的参数的这一过程，叫做“设置参数”（亦作“定义参数”、“预留参数”等）。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-190.jpg">
        </code>
        <p>对于参数的理解，可以简单理解为函数内部定义的变量，当调用该函数时，参数配置的是何值，那函数内运行的这几个变量就为何值。它和变量相比只有两点不同：</p>
        <ul class="indent">
            <li>参数没有关键字“var”的显示声明，而变量可以用“var”声明，也可以不用“var”声明（不推荐这样，因为这样就是全局变量了，而且没有<em>变量提升</em>的效果）</li>
            <li>参数是在调用函数时配置它的值的，而变量可以在任何时候配置它的值</li>
        </ul>
        <p>可以这样去理解参数的传递：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-191.jpg">
        </code>
        <p>当然，被调用的函数的内部参数还可以是变量：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-192.jpg">
        </code>
        <p>既然参数可以是变量，那也可以为表达式，也可以为任意JavaScript允许的的数据类型（JS的六种数据类型），这和我们之前所接触的JavaScript提供的各种数据操作方法并没有什么不一样。所以，这样一来，参数的配置和参数的设置需要一一对位，即配置参数的顺序和函数定义参数时的顺序一致。根据这个要求参数的配置又可以分为另外几种特殊（异常）情况。</p>
        <ul class="indent">
            <li>为函数配置了多余的参数</li>
            <li>配置的参数少于预置的参数</li>
            <li>配置的参数多于预置的参数</li>
            <li>配置的参数与预置的参数没有对位</li>
        </ul>
        <p>针对以上情况，我们在控制台中举几个例子进行说明帮助理解。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-193.jpg">
        </code>
        <p>上面这种调用函数并传递参数的方式统称为“<em>对位传参</em>”。这种传递方式，在函数定义的时候，函数体内部有几个变量，那括号内就需要出现几个参数（位置没有要求，只需要保证括号内的参数名和函数体内部的变量名一致即可）。如果括号内的参数多设置了，没有什么影响，但括号内没有声明的参数，在函数内进行了使用，除非这个变量是个全局变量（或父级函数的变量，这在“闭包”中会讲到），否则就会报出变量未定义的错误。如果参数列表内已经设置了某项参数，但是在调用函数并配置参数的时候没有对该参数进行设置，那该参数的值就为undefined。如同上例中的最后一个例子（配置的参数实际上是“a”，但参数“a”并没有参与到函数内部去）。</p>
        <p>像上例中最后一个例子，我们想让函数将参数变量“b”返回，那我们得明文地将参数变量“a”进行设置，但设置为任何值都没有影响。如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-194.jpg">
        </code>
        <p>我们之前提到过，参数实际上也是变量。在这个例子中，参数变量“a”无论为何值，它都没有参与到函数体的语句中去，所以函数最终的返回结果自然与它无关了。当然，函数也不会因为不曾使用过某个已经声明的变量而报错的。</p>
        <p>但从上面的“对位传参”的例子中可以发现一个问题，就是有的时候我们想省略某一项参数的时候，必须为省略参数至少配置一个有效值，哪怕是本来没有什么意义的“undefined”，否则会像上例中最后一个运行结果那样产生“无效标识符”的报错。这使得我们在调用一个函数时会做很多“无用功”。</p>
        <p>像这样一个应用场景，我们需要对至多5个数进行求和：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-195.jpg">
        </code>
        <p>可以发现，函数在被定义之后，我们每次调用这个函数的时候都需要给没有参与计算部分的参数传一个“0”的数值，否则它们的值将会是undefined，那么得出的运算结果就能预知得到应该是一个NaN了。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-196.jpg">
        </code>
        <p>为了解决这样的问题，我们最稳妥的做法，就是一开始就为这些参数在函数内部就设定好默认值，如果在调用阶段开发者（在用户界面上的话，是由用户决定的）配置了该参数再去使用开发者配置的数值。上面的函数经过修改后如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-197.jpg">
        </code>
        <p>这样一来，就完成了参数传递在5个以内的时候，无论是几个参数都能正确累加出结果的函数了。但在注释的时候就需要写明，最大支持的参数个数，但这通常是由项目的需求决定的（例如信用卡分期后的还款总额，其中的“分期数”就是我们参数列表中的最大值。现在一般最大的分期数是“24期”，也就是说，要实现一个不指定分期数的总额求和的函数，实际上允许最大参数个数是24个-_-!。当然，这里只是做一个参数功能的比喻，实现该功能肯定有更好的办法）。</p>
        <p>其实上例中的参数配置只是实现了“<em>依次</em>”的对位传参，也就是说，在只传递了1一个参数的时候，对应的是参数列表中的“a”；传递了2个参数，对一个参数对应的是“a”，第二个参数对应的是“b”，然后以此类推。这在处理数值求和运算的时候似乎是没有什么问题的，但若是用于处理类似于用户表单填写（有必填项，也有非必填项）的时候，问题就会出现了。我们还是先来看一次正常的对位传参的情况：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-198.jpg">
        </code>
        <p>如果，现在我们现在只想提供其中某几项信息，其它的不填写，就会出现下面的情况了：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-199.jpg">
        </code>
        <p>通过这个例子可以发现，除非我们依次对位地填写参数，否则出现的配置结果并不会乖乖的出现在应有的位置上。可以预知的是，就算我们給它配置好默认值，它们也不会按照开发者的“意念”出现在指定的位置。要解决这样的问题，我们只能采用唯一一种可行的方式了，那就是“<em>对象传参法</em>”，对象传参法在定义函数的时候只需要配置唯一的一个参数，而在调用的时候配置的参数是一个对象。首先我们来看一个将对象作为参数传递的完整示例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-200.jpg">
        </code>
        <p>我们先来做一个分析对比。这次函数定义的参数部分和之前通过“a,b,c...”设置参数列表的方式不同，这次使用了一个自定义单词“param”（译为：参数）作为参数，而参数内部也不再是那些“a,b,c...”的字母，而全是改成了<em>“param”（参数里列表内的那个词） + “.” + “自定义名称”</em>的形式。如果你对之前学习过的“对象型数据类型”还算熟悉的话，应该不难判断，这个变量就是一个对象。而在下方调用该函数时，函数内的参数应证了这一点。函数内配置的参数就是一个对象，而对象内的属性名正好与函数定时，函数体内部“param.”之后的名称正好一一对应。为了证明函数调用时的对象属性名和函数内属性名的名称是对应的，我们来做这样一个实验，就是在调用的时候更改一下配置的顺序，再观察结果。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-201.jpg">
        </code>
        <p>通过运行的结果可以清晰地对应出来，调用的时候无论怎么更改属性的顺序，函数最终的运行结果始终是按照函数内定义的顺序进行的。单是这一点“对位传参法”就已经是办不到的了。为了提升程序的“健壮性”，我们需要对函数中的所有值都定义一个默认值，防止函数在被调用的时候没有配置对象的某一项参数（某一个属性）也能显示出“适当”的结果。</p>
        <p>函数声明定义部分如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-202.jpg">
        </code>
        <p>调用函数并传递其中某些“参数”后，运行结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-203.jpg">
        </code>
        <p>上例中，对未配置的参数属性都进行了默认值的强制显示，若不需要显示配置的参数属性，在表达式的“或”逻辑运算符“||”后方用一对空引号""替代即可。用逻辑运算符处理默认字符只限于配置属性值为“非零”（也包括会在条件语句中不会自动转换成false的值）的时候，若配置的参数对象内会出现数值计算，或需要显示数值的时候（如工龄、请假次数、迟到次数），这些值都很可能为数值0。逻辑运算符都会将其自动转换为false，直接就去使用我们默认配置的值（但默认值又是一个非0的数），这显然是一个bug。如果是这样的情况，还是建议使用“三元表达式”的形式对undefined进行严格等于的比较运算进行判断更为稳妥。下面就是当参数内的属性传递的是数值0的时候出现的异常结果。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-204.jpg">
        </code>
        <p>但是在通过对象传递参数的时候千万不要忘记一个问题，就是作为参数时值的类型仍然要分为原始值类型的“<em title="数值型、字符串和布尔型">传值传递</em>”和复合值类型的“<em title="数组对象、普通对象和函数">地址传递</em>”。再次进行说明，凡是是需要进行包装才能成为对象的，即通过“Object()”方法转换后的值不等于自身的，那它们进行的赋值操作就是“传值传递”。凡是通过“Object()”方法转换后的值仍然等于自身的，那它们进行的赋值操作就是“地址传递”。这一理论，在数据作为参数时仍然成立（其实在任何语境中都成立），需要加以注意。</p>
        <p>如果参数出现同名，和对变量的处理一样，采用同名参数中最后一个参数的值。</p>

        <p>函数也具有<em>length</em>属性，但这个属性不是用来获取函数的个数的，而是用来表示函数内参数的个数的。这个属性显示的结果是函数在定义时预置的参数个数，与被调用的时候使用的参数个数没有关系。如例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-205.jpg">
        </code>
        <p>上例中，需要注意，运行后的那个结果并不是值函数运算结果，而是该函数的“length”属性的运算结果。可以发现，无论调用函数的时候怎么去配置函数的参数，最终结果都是3，表示的是函数定义时内部的三个参数“a,b,c”。</p>
        <p>在某些特定的情况下，我们根本不知道函数在调用的时候到底需要配置几个参数，如刚开始我们在讲解通过配置参数来进行求和的那个例子（最多只能配置5个参数），但在实际调用时，可能用到的参数不到5个，或者或者会超出5个。这个时候无论通过普通的“对位传参”再处理默认值的方式，还是通过“对象传参”再处理默认值的方式都基本上是行不通的。为了应对这种情况，JavaScript对函数提供了一个“arguments”对象来应对以上情况。</p>
        <p>我们首先要对“arguments”这个对象进行一个基本概念的了解。“arguments”对象只能出现在函数内部，在“全局空间”里该对象是无效的。该对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-208.jpg">
        </code>
        <p>示例运行后，每次函数被调用后最后的结果都会有一个undefined，这是函数的默认返回值，我们不必理会。我们只用观察每次在调用函数“numFn()”时，为其配置的不同参数。还记得，之前我们在通过“对位传参”的方式调用函数时，超出原始函数预设的参数个数后，超出预设参数个数部分的参数会被忽略掉，但这次显然是没有的。因为，这次的预设参数就一个“param”，但是我们在后面进行了2次配置3个参数的调用和1次配置2个参数的调用（最后一个结果为undefined应是在清理之中）都没有出现异常，arguments对象在这里的作用想必应该能分析得出来了，也就是说它能会忽视函数定义时参数定义的个数，以实际调用时配置的参数为准，也就是说函数的括号内哪怕没有预置参数都是可以的。我们通过arguments对象的“length”属性（之前的length属性是对函数名使用的）来再次证明这一点。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-209.jpg">
        </code>
        <p>通过这个例子我们就已经证明了，哪怕声明定义函数的时候没有设置参数，在调用的时候仍然可以为其配置参数（但是在实际开发中仍然建议保留那个参数，以用于说明该函数的运行是依赖参数实现的）。根据上面两个例子总结出来的特点，再根据我们之前所学的知识点，实现一个不确定位数的“求和函数”应该就不那么困难了。</p>
        <p>arguments对象除了可以读取参数，还可以为参数赋值。但在严格模式下不支持这种做法。</p>
        <p>需要注意的是，虽然arguments很像数组，但它是一个对象（其实它是一个“类似数组”）。数组专有的方法（比如push()、pop()和forEach()等方法），不能在arguments对象上直接使用。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-210.jpg">
        </code>
        <p>如果你对数组的操作方法学习得足够牢固的话，应该还记得在数组操作中有一个方法，它可以把“类似数组”转化成一个真正的数组，那就是使用“slice()”方法在数组原型类中的子方法“call()”。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-211.jpg">
        </code>
        <p>那问题来了，将arguments对象转换成一个数组的意义是什么呢？之前我们提到过（在上例中也有一定程度的表现），就是在arguments对象转化成一个数组对象之后，它可以使用数组的专用方法。通过目前已经学习过6种数据类型可以发现，数组的操作方法是最多的，这也成就了数组的操作是最为灵活的，最为方便的。其它数据格式不能完成的操作，在通过特定方式转换为数组之后都成为了可能。比如我们现在拿一个本不能修改其内容的字符串来进行举例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-212.jpg">
        </code>
        <p>通过上例可以发现，字符串拥有和数组一样的“length”属性，也可以像数组那样通过下标对值进行访问，但是却不能通过下标对位地去修改字符串内的值。但若将字符串转换为数组后，情况就有所改观了。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-213.jpg">
        </code>
        <p>虽然这个示例中的行为显得有些多余，在实际操作中我们只需要将变量“var str = "baidu"; str = "google"”即可完成这个操作，但这里的示例希望的是发现数组的操作性是强是弱的问题。示例展示了一个通过下标本不能修改的字符串“baidu”通过转换为数组后硬是修改为了“google”的过程。</p>
        <p>根据数组可操作性的特点，我们再来尝试一个，对传入任意数量参数的值求平均值的例子：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-214.jpg">
        </code>
        <p>将上面的代码定义的函数在控制台内进行多次不同的参数配置调用，观察函数运行后返回的结果。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-215.jpg">
        </code>
    </section>
    <!-- 章节练习 -->
    <section class="unitPractice">
        <h3>&lt;章节练习三&gt;</h3>
        <p>1、通过“arguments”对象+“for循环”的方式编写一个不确定参数个数的求和计数器函数；</p>
        <p>2、在不使用“arguments”对象和“for循环”的前提下，完成对传入参数个数不确定时的平均值计算；</p>
        <p>3、配置参数的统一格式为“functionName（param）”的格式,“functionName”为自定义函数名，“（param）”为函数声明时自定义名称的参数。函数被调用时，参数为不限制个数的数值型数据，多个参数用“,”进行分割。</p>
        <p>&lt;扩展功能&gt;</p>
        <p>当调用函数时，参数列表内任意一个值不为数字，函数执行后返回的结果为“参数只能为数字，请检查参数的配置！”</p>
    </section>
</root>






