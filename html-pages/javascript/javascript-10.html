<root data-root="JavaScript函数">
    <!-- 函数概述 -->
    <section class="mt0">
        <h3>函数概述</h3>
        <p>所谓“函数”，就是使用关键字“<em>function</em>”定义的一段有<em>独立作用域</em>，能被<em>反复执行</em>的语句块。它在JavaScript中也是以一种“值”的方式存在的（JS允许的六种数据类型之一），和其它数据类型相比，它是一种可以接收“<em>参数</em>”的，可运行的值，除此之外，它并没有任何的不同。</p>
        <p>但JavaScript作为一个“面向对象”和“函数式编程”的语言，“函数”部分自然是一个重点，而且也有一些区别于其它语言，即可以称为特色的地方。接下来我们就对JS中的“函数”进行详细的学习。</p>
	</section>
    <section>
        <h3>函数声明的方式</h3>
        <p>首先，要提到的就是函数的声明方式，主要有四种：</p>
        <dl class="attrExplain">
            <dt>利用关键字“function”声明</dt>
            <dd>基本语法格式为：</dd>
            <dd>
<code class="ideCode-js">function fnName(param) {
    // 需要执行的一条或多条语句
}</code>
            </dd>
            <dd>function关键字后空格紧跟一个自定义的<em>函数名</em>，该名称的命名方式、要求与变量的命名方式、要求基本一致（即避免出现特殊符号，不使用关键字、保留字，名称开头不使用数字等），名称后发紧跟一对小括号“<em>()</em>”，小括号内部可以根据需求配置一个或多个<em>参数</em>，小括号后方又得跟一对花括号“<em>{}</em>”花括号，函数内所有的语句都需要放置于该花括号内部。</dd>

            <dt>利用函数表达式进行赋值声明</dt>
            <dd>基本语法格式为：<em>var fnName = function(param list) {...};</em></dd>
            <dd>这种函数的声明方式是将函数当做了一个表达式，然后将表达式赋给了函数名，这和“var num = 2 + 3;”、“var str = "这是第" + num + "行字符串";”等这些表达式并没有什么不同。</dd>
            <dd>但通过表达式声明的函数需要注意两点。第一点，这样声明的函数，需要先声明后调用，否则像上面的函数名的值将为undefined;第二点，表达式内部的function后方不需要再空格+函数名了，如果这样写，function后方的函数名只能被函数内部调用，在外部是无法使用的。以上两种定义函数的方式如例：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-183.jpg">
                </code>
            </dd>
            <dd>除了上述需要注意的两点外，这种方式声明的函数和利用funciton关键字定义的函数并没有什么区别。</dd>

            <dt>利用构造函数“Function”声明</dt>
            <dd>基本语法格式为：<em>var fnName = new Function(param list, ...);</em></dd>
            <dd>这种写法是将参数列表和函数体放置在了一起同样作为了参数。构造函数内的参数无论有多少个，始终会将其最后一个参数作为函数体去执行，如果只有一个参数，那这个参数就是函数体内部的代码。但使用这种方式需要注意的是，就算是参数和函数体的语句也是要作为字符串去呈现的，即需要给参数和函数体执行的代码都加上引号，否则会报“未定义”的错误。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-184.jpg">
                </code>
            </dd>
            <dd>这种将参数和函数体内的语句糅杂在一起的写法非常不直观，实际开发中并不推荐使用。</dd>

            <dt>自调用函数（即时执行函数）</dt>
            <dd>基本语法格式为：<em>(function() {...})(param);</em></dd>
            <dd>这种函数声明方式的最大特点是“即时性”。它不需要任何调用，即可立即执行。它可以有函数名，通常也可无函数名。它执行的原理是利用小括号将函数自身括起来，以到达提升括号内函数表达式优先级的作用，括号内部的函数生效后，又紧接着后面的括号进行函数的调用，从而实现自我调用的效果。如下例：</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-222.jpg">
                </code>
            </dd>
            <dd>这种函数的声明方式和其它函数的声明方式一样，它仍然有自己的独立<em>作用域</em>。自调用函数还有一个特点就是，它的运行虽然还是在程序的<em>独立线程</em>完成的，但是却可以达到程序在<em>主线程</em>完成的效果。（这一点在“函数的作用域”一节中进行讲解）</dd>
        </dl>
	</section>
    <section>
        <h3>函数的返回值</h3>
        <p>每一个函数都会有一个返回值，这个返回值可以通过关键字“<em>return</em>”进行设置，若未<em title="编程技术中的术语，相对于“隐式”">显示</em>地设置函数的返回值，那函数会默认返回一个<em>undefined</em>值。如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-216.jpg">
        </code>
        <p>但若手动地设置了函数的返回值，即手动地设置了关键字“return”空格之后的值后，函数将不再会返回undefined了，而是返回开发者手动设置的那个值：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-217.jpg">
        </code>
        <p>上例中，通过手动设置了关键字return之后的值后，undefined就没有再出现了。但在手动设置函数返回值的时候需要注意的一点就是，代码一旦执行完成“return”这行语句后，代码就会跳出整个函数，即不再执行当前函数的后续语句，这一点可以善加利用，特别是在一些条件语句内部使用。基本使用示例如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-218.jpg">
        </code>
        <p>根据上例返回的结果可以发现，函数“fn()”内的控制台输出“4”和“5”并没有执行，是因为代码执行return之后，该函数也就结束了，函数执行完后，还是会依次执行之后的语句。但在这里还需要补充一点，就是“return”之后的值只能有一个。如果尝试返回多个值，那得到的结果始终是最后一个值：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-219.jpg">
        </code>
        <p>在有的使用场景中，如果真的需要函数返回多个值，那就只有将值组合成一个对象进行返回了，然后再通过访问函数的属性去获取返回的具体值，如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-220.jpg">
        </code>
        <p>也可以改成这种形式：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-221.jpg">
        </code>
        <p>利用这一点，还可以在函数内部去声明一个子函数，通过调用主函数去调用子函数从而去实现一个<em>功能链</em>。以下为定义方式，可以将代码复制在自行的<em title="Web继承开发环境。这里可以在浏览器控制台编写并运行，也可以是代码编辑器里编写代码，然后在对应引用这个JS的HTML页面的浏览器控制台里进行调用">Web IDE</em>里面按照上例的方式进行调用，需要注意函数值要运行需要在该值的后方加上括号。</p>
<code class="ideCode-js">// 创建主函数
function mainFn() {
	var mainTxt = "【这是子函数";
	// 创建子函数1
	function childFn1() {
		var childTxt = "一】";
		return mainTxt + childTxt;
	}
	// 创建子函数2
	function childFn2() {
		var childTxt = "二】";
		return mainTxt + childTxt;
	}
	// 将两个函数赋予一个别名以供执行时调用
	return {
		fn1: childFn1,
		fn2: childFn2
	};
}</code>
	</section>
	<section>
        <h3>函数的声明方式</h3>
        <p>和声明和一个变量一样，在同一个作用域内，若函数重复声明，后声明的函数会覆盖之前声明过的函数，使之前声明过的任何同名函数无效。所以在大型网站/应用中，声明函数也应该要有和命名变量那样的“命名空间”的思维，即将函数当做对象中的一个方法那样去使用。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-185.jpg">
        </code>
        <p>上面的函数改成通过“对象”去调用“方法”的形式后再次执行，表现和结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-186.jpg">
        </code>
        <p>这样写虽然在很大程度上避免了函数名的重名，从而避免同名函数被覆盖的情况。但需要提醒的是，只要是通过表达式赋值声明的方式都会面对一个问题，就是声明和调用的次序问题。我们来看几个例子：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-187.jpg">
        </code>
        <p>通过上例可以发现，通过函数表达式的方式声明的函数，在先调用和声明的时候报错了。当然这种后声明不管是通过一个变量声明还是通过一个对象内的属性声明，结果都是一样的（会报错）。所以，在大型网站/应用中需要使用对象方法来定义一个函数的，但又不希望将所有函数都放置于JS文件开头（这样一来所有的函数的调用或调用函数处理的事件的都得放置于这些定义函数的后面，检索起来非常不方便），就可以使用JS提供的一个事件“<em>window.onload = function() {...加载执行完成后的事件...}</em>”，这个事件的作用是保证页面所有文档（包括图片）都加载完成之后才去执行代码。</p>
        <p>我们通过一个这样的示例就明白了：（由于涉及到“事件的调用”，我们的代码编写部分在编辑器内进行）</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-188.jpg">
        </code>
        <p>在控制台中运行的结果就是：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-189.jpg">
        </code>
        <p>但若将外层的事件“window.onload”去掉之后，程序就会报错了，会告诉你函数“fnExp_1”和“fnExp_2”未定义。但千万不要认为将函数定义在程序后面会有这么多麻烦就放弃使用这种方式了。其实将函数定义在后面，而在代码的前面进行调用有诸多好处。其中一点，就是可以让您的代码像一本书一样具有“目录”（前提是有良好的注释），可以通过“现代”代码编辑器快捷键快速地跳转到函数的原始定义部分，这些定义的函数就像是“目录”所对应的“文章内容”一样。（现在绝大多数的编辑器都提供类似于“跳转到函数定义部分”的功能，如：Brackets的快捷键是“Ctrl + J”，Webstorm的快捷键是“Ctrl + B”）。</p>
        <p>但和书本不一样的是，函数调用的顺序或函数定义的顺序都不一定是需要按照先后顺序对应的，我们只需要在调用函数的时候按照功能流程来“排序”即可，而不用关心函数定义的顺序，这表现出了函数的灵活性优点。</p>
        <p>函数可以在页面中的任何地方声明定义，但根据ECMAScript的规范，函数是不能在条件语句内声明的，这点在使用的过程中需要特别注意。虽然现在现代的浏览器已经允许了这种行为，但为了浏览器兼容考虑还是应该尽量避免这种做法：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-206.jpg">
        </code>
        <p>如果实在是要这么做，最好是使用函数表达式的声明方式去进行从定义，这样可以达到最好的浏览器兼容性。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-207.jpg">
        </code>
        <p>而实际上最佳实践是为有可能需要执行的代码始终定义一个函数，只是按条件的成立与否再决定是否去调用这个函数。因为按照条件成立再去声明一个函数，如果遇到条件不成立时，在后面代码中去调用了一个没有声明的函数则会造成“未定义”的错误。我们没有必要给自己去找这样的麻烦，优秀的代码只和“可读性”、“字节量”和“性能”这几个因素挂钩，而不在于实现的方式多么的“独特”。</p>
    </section>
    <!-- 函数的参数 -->
    <section>
        <h3>函数的参数</h3>
        <p>在很早之前我们就接触过了函数的<em>参数</em>，它是让函数<em>可复用</em>的关键性存在。就是当程序里很多地方都在做着同样一件事件，但只是部分需要呈现的内容不同的时候，我们就可以使用配置参数的形式来完成一个函数的功能。如在学习JavaScript之初，我们就会接触到的“<em>alert()</em>”函数和“console.log()”方法一样，我们只需要在使用它们的时候往该函数或方法的括号内添加我们需要显示的内容即可让它实现其功能。我们在往括号里添加显示内容的这一个过程就叫做“配置参数”（亦作“传入参数”、“提供参数”等），而对于JavaScript设计这些方法的时候为其括号内添加的参数的这一过程，叫做“设置参数”（亦作“定义参数”、“预留参数”等）。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-190.jpg">
        </code>
        <p>对于参数的理解，可以简单理解为函数内部定义的变量，当调用该函数时，参数配置的是何值，那函数内运行的这几个变量就为何值。它和变量相比只有两点不同：</p>
        <ul class="indent">
            <li>参数没有关键字“var”的显示声明，而变量可以用“var”声明，也可以不用“var”声明（不推荐这样，因为这样就是全局变量了，而且没有<em>变量提升</em>的效果）</li>
            <li>参数是在调用函数时配置它的值的，而变量可以根据需要在任何时候给它赋值</li>
        </ul>
        <p>可以这样去理解参数的传递：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-191.jpg">
        </code>
        <p>当然，被调用的函数的内部参数还可以是变量：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-192.jpg">
        </code>
        <p>当然，上面的这种比喻法只是为了帮助理解，实际上参数应该在函数作用域内部生效，而在函数外部是无法访问的，这里需要注意鉴别。</p>
	</section>
    <section>
        <h3>对位传参法</h3>
        <p>既然参数可以是变量，那也可以为表达式，也可以为任意JavaScript允许的的数据值类型（JS的六种数据值类型），这和我们之前所接触的JavaScript提供的各种数据操作方法并没有什么不一样。所以，这样一来，参数的配置和参数的设置需要一一对位，即配置参数的顺序和函数定义参数时的顺序一致。根据这个要求参数的配置又可以分为另外几种特殊（异常）情况。</p>
        <ul class="indent">
            <li>在定义时为函数配置了多余的参数 —— 多余参数自动忽略</li>
            <li>在调用时配置的参数少于定义预置的参数 —— 未配置的参数的值为“undefined”</li>
            <li>在调用时配置的参数多于预置的参数 —— 多余参数自动忽略</li>
            <li>在调用时配置的参数与定义预置的参数没有对位（主观认为） —— 按函数本身的对位方式执行</li>
        </ul>
        <p>针对以上情况，我们在控制台中举几个例子进行说明帮助理解。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-193.jpg">
        </code>
        <p>上面这种调用函数并传递参数的方式统称为“<em>对位传参</em>”。这种传递方式，在函数定义的时候，函数体内部有几个变量，那括号内就需要出现几个参数。如果定义时括号内的参数多设置了，没有什么影响的。如果参数列表内已经设置了某项参数，但是在调用函数并配置参数的时候没有对该参数进行设置，那该参数的值就为undefined。如同上例中的最后一个例子（配置的参数实际上是“a”，但参数“a”并没有参与到函数内部去）。</p>
        <p>像上例中最后一个例子，我们想让函数将参数变量“b”返回，那我们得明文地将参数变量“a”进行设置，但设置为任何值都没有影响。如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-194.jpg">
        </code>
        <p>我们之前提到过，参数实际上也是变量。在这个例子中，参数变量“a”无论为何值，它都没有参与到函数体的语句中去，所以函数最终的返回结果自然与它无关了。当然，函数也不会因为不曾使用过某个已经声明的变量而报错的。</p>
        <p>但从上面的“对位传参”的例子中可以发现一个问题，就是有的时候我们想省略某一项参数的时候，必须为省略参数至少配置一个有效值，哪怕是本来没有什么意义的“undefined”，否则会像上例中最后一个运行结果那样产生“无效标识符”的报错。这使得我们在调用一个函数时会做很多“无用功”。</p>
        <p>像这样一个应用场景，我们需要对至多5个数进行求和：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-195.jpg">
        </code>
        <p>可以发现，函数在被定义之后，我们每次调用这个函数的时候都需要给没有参与计算部分的参数传一个“0”的数值，否则它们的值将会是undefined，那么得出的运算结果就能预知得到应该是一个NaN了。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-196.jpg">
        </code>
        <p>为了解决这样的问题，我们最稳妥的做法，就是一开始就为这些参数在函数内部就设定好默认值，如果在调用阶段开发者（在用户界面上的话，是由用户决定的）配置了该参数再去使用开发者配置的数值。上面的函数经过修改后如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-197.jpg">
        </code>
        <p>这样一来，就完成了参数传递在5个以内的时候，无论是几个参数都能正确累加出结果的函数了。但在注释的时候就需要写明，最大支持的参数个数，但这通常是由项目的需求决定的（例如信用卡分期后的还款总额，其中的“分期数”就是我们参数列表中的最大值。现在一般最大的分期数是“24期”，也就是说，要实现一个不指定分期数的总额求和的函数，实际上允许最大参数个数是24个-_-!。当然，这里只是做一个参数功能的比喻，实现该功能肯定有更好的办法）。</p>
        <p>其实上例中的参数配置只是实现了“<em>依次</em>”的对位传参，也就是说，在只传递了1一个参数的时候，对应的是参数列表中的“a”；传递了2个参数，对一个参数对应的是“a”，第二个参数对应的是“b”，然后以此类推。这在处理数值求和运算的时候似乎是没有什么问题的，但若是用于处理类似于用户表单填写（有必填项，也有非必填项）的时候，问题就会出现了。我们还是先来看一次正常的对位传参的情况：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-198.jpg">
        </code>
        <p>如果，现在我们现在只想提供其中某几项信息，其它的不填写，就会出现下面的情况了：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-199.jpg">
        </code>
        <p>对位传参法是JavaScript中比较常见而且最简单的一种传参方式了，它可以帮助我们快速地实现一些“小型”函数功能的封装，以提升该函数的可复用性，但如果是要应付以上应用情景的需求，那对位传参法是不能够满足的了，但我们会通过后续讲解的传参方式来应付这样的功能需求。</p>
	</section>
    <section>
        <h3>对象传参法</h3>
        <p>通过上一节最后一个例子可以发现，除非我们依次对位地填写参数，否则出现的配置结果并不会乖乖的出现在应有的位置上。可以预知的是，就算我们給它配置好默认值，它们也不会按照开发者的“意念”出现在指定的位置。要解决这样的问题，我们只能采用唯一一种可行的方式了，那就是“<em>对象传参法</em>”，对象传参法在定义函数的时候只需要配置唯一的一个参数，而在调用的时候配置的参数是一个对象。首先我们来看一个将对象作为参数传递的完整示例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-200.jpg">
        </code>
        <p>我们先来做一个分析对比。这次函数定义的参数部分和之前通过“a,b,c...”设置参数列表的方式不同，这次使用了一个自定义单词“param”（译为：参数，它是调用阶段配置的那个对象参数的别名）作为参数，而参数内部也不再是那些“a,b,c...”的字母，而全是改成了<em>“param”（参数里列表内的那个词） + “.” + “自定义名称”</em>的形式。如果你对之前学习过的“对象型数据类型”还算熟悉的话，应该不难判断，这个变量就是一个对象。而在下方调用该函数时，函数内的参数应证了这一点。函数内配置的参数就是一个对象，而对象内的属性名正好与函数定时，函数体内部“param.”之后的名称正好一一对应。为了证明函数调用时的对象属性名和函数内属性名的名称是对应的，我们来做这样一个实验，就是在调用的时候更改一下配置的顺序，再观察结果。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-201.jpg">
        </code>
        <p>通过运行的结果可以清晰地对应出来，调用的时候无论怎么更改属性的顺序，函数最终的运行结果始终是按照函数内定义的顺序进行的。单是这一点“对位传参法”就已经是办不到的了。为了提升程序的“健壮性”，我们需要对函数中的所有值都定义一个默认值，防止函数在被调用的时候没有配置对象的某一项参数（某一个属性）也能显示出“适当”的结果。</p>
        <p>函数声明定义部分如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-202.jpg">
        </code>
        <p>调用函数并传递其中某些“参数”后，运行结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-203.jpg">
        </code>
        <p>上例中，对未配置的参数属性都进行了默认值的强制显示，若不需要显示配置的参数属性，在表达式的“或”逻辑运算符“||”后方用一对空引号""替代即可。用逻辑运算符处理默认字符只限于配置属性值为“非零”（也包括会在条件语句中不会自动转换成false的值）的时候，若配置的参数对象内会出现数值计算，或需要显示数值的时候（如工龄、请假次数、迟到次数），这些值都很可能为数值0。逻辑运算符都会将其自动转换为false，直接就去使用我们默认配置的值（但默认值又是一个非0的数），这显然是一个bug。如果是这样的情况，还是建议使用“三元表达式”的形式对undefined进行严格等于的比较运算进行判断更为稳妥。下面就是当参数内的属性传递的是数值0的时候出现的异常结果。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-204.jpg">
        </code>
        <p>但是在通过对象传递参数的时候千万不要忘记一个问题，就是作为参数时值的类型仍然要分为原始值类型的“<em title="数值型、字符串和布尔型">传值传递</em>”和复合值类型的“<em title="数组对象、普通对象和函数">地址传递</em>”。再次进行说明，凡是是需要进行包装才能成为对象的，即通过“Object()”方法转换后的值不等于自身的，那它们进行的赋值操作就是“传值传递”。凡是通过“Object()”方法转换后的值仍然等于自身的，那它们进行的赋值操作就是“地址传递”。这一理论，在数据作为参数时仍然成立（其实在任何语境中都成立），需要加以注意。</p>
        <p>如果参数出现同名，和对变量的处理一样，采用同名参数中最后一个参数的值。</p>

        <p>函数也具有<em>length</em>属性，但这个属性不是用来获取函数的个数的，而是用来表示函数内参数的个数的。这个属性显示的结果是函数在定义时预置的参数个数，与被调用的时候使用的参数个数没有关系。如例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-205.jpg">
        </code>
        <p>上例中，需要注意，运行后的那个结果并不是值函数运算结果，而是该函数的“length”属性的运算结果。可以发现，无论调用函数的时候怎么去配置函数的参数，最终结果都是3，表示的是函数定义时内部的三个参数“a,b,c”。</p>
	</section>
    <section>
        <h3>参数的属性arguments</h3>
        <p>在某些特定的情况下，我们根本不知道函数在调用的时候到底需要配置几个参数，如刚开始我们在讲解通过配置参数来进行求和的那个例子（最多只能配置5个参数），但在实际调用时，可能用到的参数不到5个，或者或者会超出5个。这个时候无论通过普通的“对位传参”再处理默认值的方式，还是通过“对象传参”再处理默认值的方式都基本上是行不通的。为了应对这种情况，JavaScript对函数提供了一个“arguments”对象来应对以上情况。</p>
        <p>我们首先要对“arguments”这个对象进行一个基本概念的了解。“arguments”对象只能出现在函数内部，在“全局空间”里该对象是无效的。该对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-208.jpg">
        </code>
        <p>示例运行后，每次函数被调用后最后的结果都会有一个undefined，这是函数的默认返回值，我们不必理会。我们只用观察每次在调用函数“numFn()”时，为其配置的不同参数。还记得，之前我们在通过“对位传参”的方式调用函数时，超出原始函数预设的参数个数后，超出预设参数个数部分的参数会被忽略掉，但这次显然是没有的。因为，这次的预设参数就一个“param”，但是我们在后面进行了2次配置3个参数的调用和1次配置2个参数的调用（最后一个结果为undefined应是在清理之中）都没有出现异常，arguments对象在这里的作用想必应该能分析得出来了，也就是说它能会忽视函数定义时参数定义的个数，以实际调用时配置的参数为准，也就是说函数的括号内哪怕没有预置参数都是可以的。我们通过arguments对象的“length”属性（之前的length属性是对函数名使用的）来再次证明这一点。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-209.jpg">
        </code>
        <p>通过这个例子我们就已经证明了，哪怕声明定义函数的时候没有设置参数，在调用的时候仍然可以为其配置参数（但是在实际开发中仍然建议保留那个参数，以用于说明该函数的运行是依赖参数实现的）。根据上面两个例子总结出来的特点，再根据我们之前所学的知识点，实现一个不确定位数的“求和函数”应该就不那么困难了。</p>
        <p>arguments对象除了可以读取参数，还可以为参数赋值。但在严格模式下不支持这种做法。</p>
        <p>需要注意的是，虽然arguments很像数组，但它是一个对象（其实它是一个“类似数组”）。数组专有的方法（比如push()、pop()和forEach()等方法），不能在arguments对象上直接使用。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-210.jpg">
        </code>
        <p>如果你对数组的操作方法学习得足够牢固的话，应该还记得在数组操作中有一个方法，它可以把“类似数组”转化成一个真正的数组，那就是使用“slice()”方法在数组原型类中的子方法“call()”。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-211.jpg">
        </code>
        <p>那问题来了，将arguments对象转换成一个数组的意义是什么呢？之前我们提到过（在上例中也有一定程度的表现），就是在arguments对象转化成一个数组对象之后，它可以使用数组的专用方法。通过目前已经学习过6种数据类型可以发现，数组的操作方法是最多的，这也成就了数组的操作是最为灵活的，最为方便的。其它数据格式不能完成的操作，在通过特定方式转换为数组之后都成为了可能。比如我们现在拿一个本不能修改其内容的字符串来进行举例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-212.jpg">
        </code>
        <p>通过上例可以发现，字符串拥有和数组一样的“length”属性，也可以像数组那样通过下标对值进行访问，但是却不能通过下标对位地去修改字符串内的值。但若将字符串转换为数组后，情况就有所改观了。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-213.jpg">
        </code>
        <p>虽然这个示例中的行为显得有些多余，在实际操作中我们只需要将变量“var str = "baidu"; str = "google"”即可完成这个操作，但这里的示例希望的是发现数组的操作性是强是弱的问题。示例展示了一个通过下标本不能修改的字符串“baidu”通过转换为数组后硬是修改为了“google”的过程。</p>
        <p>根据数组可操作性的特点，我们再来尝试一个，对传入任意数量参数的值求平均值的例子：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-214.jpg">
        </code>
        <p>将上面的代码定义的函数在控制台内进行多次不同的参数配置调用，观察函数运行后返回的结果。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-215.jpg">
        </code>
    </section>
    <!-- 章节练习 -->
    <section class="unitPractice">
        <h3>&lt;章节练习一&gt;</h3>
        <p>1、通过“arguments”对象+“for循环”的方式编写一个不确定参数个数的求和计数器函数；</p>
        <p>2、配置参数的统一格式为“functionName（param）”的格式,“functionName”为自定义函数名，“（param）”为函数声明时自定义名称的参数。函数被调用时，参数为不限制个数的数值型数据，多个参数用“,”进行分割。</p>
        <p>&lt;扩展功能&gt;</p>
        <p>当调用函数时，参数列表内任意一个值不为数字，函数执行后返回的结果为“参数只能为数字，请检查参数的配置！”</p>
    </section>
    <section>
    	<h3>函数递归</h3>
    	<p>JavaScript和其它编程技术一样，拥有一种函数在执行的时候调用自身的实现，这种实现在编程技术中叫做“<em>递归</em>”，通过递归可以同更少的代码完成很多需要大量代码，甚至是不确定代码所能完成的事。我们先在看一个简单的“递归”实现的例子：</p>
    	<code class="indent">
            <img src="img/code/jscode/code-js-302.jpg">
        </code>
        <p>在控制台中通过传入不同的数字参数，执行的结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-303.jpg">
        </code>
        <p>通过上面的例子可以简单地分析递归的原理，可以发现它和循环十分的相似。在使用递归时同样要注意一个问题，就是要防止结束条件的不明确导致出现“死循环”，导致浏览器崩溃。根据浏览器不同报出的错误描述各有差异，但总得来说都属于“RangeError”类型的错误，按照O'Reilly技术书籍出版社出版的书籍中的称呼叫做“调用栈错误”，书中也建议使用“<em>迭代</em>”（即循环）来替代“递归”，防止有些浏览器对递归迭代周期过长而产生的报错。</p>
		<p>尽管如此，在思路和结束条件都比较明确的时候用递归去执行一些需要重复的“递增”或“递减”算法还是一件比较“有趣”的事的，它和执行一个循环一样，可以减少我们大部分不必要的重复性的工作，我们来看下面这样一个示例，<a href="html-pages/javascript/codeEffect/code-003.html" target="_blank">HTML代码部分</a>如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-304.jpg">
        </code>
        <p>主要是CSS代码如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-305.jpg">
        </code>
        <p>JavaScript代码如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-306.jpg">
        </code>
        <h4>运行效果：</h4>
        <iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-003.html"></iframe>
        <p>代码的执行顺序在注释中都已经标注得很清楚了，结合HTML和CSS部分来阅读，应该不难分析出代码执行的原理。只是其中的“获取当前的子节点”注释所对应的那行代码是一个链式叠加的过程，也就是第一次是“testDiv.children[0]”，第二次就是“testDiv.children[0].children[0]”，第三次就是“testDiv.children[0].children[0].children[0]”，依次类推，每次的“children[0]”表示当前节点下的第一个（也是唯一一个）子元素节点，一直到满足结束条件后“return”为止。</p>
        <p>其实这个部分的代码用一个循环语句（如for循环）也同样能实现效果，可自行思考实现思路。但需要说明的是，上例大量地对DOM节点进行了查询和设置，触发了浏览器内核（排版引擎）多次“<em title="reflow">重排</em>”和“<em title="repaint">重绘</em>”操作，对性能消耗非常明显，经多次测试（测试环境：Intel CPU i7-6500U 2.5GHz~2.6GHz），耗时是在11ms~15ms之间，在实际开发中应该还是尽量要避免这样的操作。</p>
    </section>
    <section>
    	<h3>函数的作用域</h3>
    	<p>在之前我们就提到过，JavaScript和其它编程语言不同，它的变量作用域只分为两种类型，一种是“全局作用域”，一种是“函数作用域”（而Java等语言的作用域还有块级作用域，即if判断、for循环等语句都有自己独立的作用域）。这样的做法有是有利有弊的：“利”在减少了程序中的“传值”操作，使代码结构更加简洁高效，“弊”在若代码量过大时可能会难以管理变量，导致逻辑结构混乱。不过这种弊端通过现在的代码编辑器基本可以很好的克服。</p>
    	<p>虽然说，JavaScript的作用域只有两种，但并不是说在一个程序中作用域就只有两个，实际上在一个用JavaScript开发的完整项目中，作用域会多达几十个甚至上百个之多。我们来看这样一个示例，数数这样一个简单的点击操作涉及到了几个作用域：</p>
    	<code class="indent">
            <img src="img/code/jscode/code-js-307.jpg" title="答案是6个">
        </code>
        <p>如果是之前就对函数的作用域有所了解，稍微仔细一点也不难数出上例整个点击事件中所包含的作用域个数（实在数不出的，也可以将鼠标移于上例代码图上，它会告诉你答案）。其实对于这样一个函数实现一个功能的代码结构来讲，只需要数出代码中有几个“function”关键字再加上一个全局作用域即是作用域的实际个数了。</p>
        <p>上例中这种函数互相分离调用的的结构还是比较好观察和阅读的，但当函数内涉及到嵌套时情况又有所不同了。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-308.jpg">
        </code>
        <p>为了分清代码层次结构，上例启用了编辑器的缩进对齐线的插件。通过观察控制台输出语句“console.log()”中的参数颜色可以发现（参数颜色为“紫色”即表示可以访问到该变量），函数最外层只能访问到同在一个作用域下的“red”，而“green”和“blue”不能访问（如果运行会报出未定义的错误）；名为“setGreen”的第二层函数内则能访问到外层的“red”和本层的“green”，而“blue”仍旧是不能访问的；名为“setBlue”的第三层函数则全部变量都能够访问到。</p>
        <p>通过总结可以发现，在同一个函数内，只要存在“父子”关系的函数，子级函数都可以访问父级（也包括祖先级）函数的变量，而父级函数是不能访问子级函数的变量的。也就是说作用域是一个单向的“链”，在JavaScript中，我们将其称作“<em>作用域链</em>”，而且不同的函数之间的作用域也是不互通的，要访问同一个变量，只有通过访问全局作用域去实现，如下图所示：</p>
        <code class="indent">
            <img src="img/content/javascript/jsScope-1.jpg">
        </code>
        <p>如上图所示，“函数1”、“函数2”和“函数3”三个函数之间没有任何直接关系，它们之间定义的变量或函数都是自己所独有的，不仅函数间不能互相访问，而且全局作用域也“无权”访问函数的内部。但这些全局作用域下的函数都可以通过访问全局作用域来得到同一个变量，而且它们都是可以互相调用的。</p>
        <p>对于同一个函数而言，若其下有多层、多级函数，要访问同一个变量，也只有通过它们共同的“父级”函数作用域来进行访问和操作，如下图所示：</p>
        <code class="indent">
            <img src="img/content/javascript/jsScope-2.jpg">
        </code>
		<p>和之前在全局作用域下的函数一样，处于“主函数”下的“子函数1”和“子函数2”是可以互相调用的，但是它们不能互相访问各自内部所定义的变量或函数，只能通过访问定义在“主函数”作用域下的变量来操作共同的数据。</p>
		<p>当同级函数互相调用时，其作用域也是无法互通的，如例：</p>
   		<code class="indent">
            <img src="img/code/jscode/code-js-309.jpg">
        </code>
        <p>在控制台中调用函数“fn_B”后报错：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-310.jpg">
        </code>
        <p>但若采用之前我们所讲解过的“参数”的相关特性，则能很好的解决这一个问题，如例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-311.jpg">
        </code>
        <p>得到正确的结果“3”：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-312.jpg">
        </code>
        <p>这样一来函数“fn_B”就能正确地接收函数“fn_A”返回的运算结果，并且不需要将函数“fn_A”作为函数“fn_B”的子函数来传递作用域了，使函数“fn_A”能被更多的其它函数所调用，从而起到了提升代码复用性的目的。</p>
        <p>JavaScript是“函数式编程”模式的一个代表，而“函数式编程”也是未来编程语言的一个主流方向之一，能准确的理解函数几种参数的配置方式和深刻理解函数的作用域，就已经为这种编程模式打下了非常好的思想基础了。</p>
    </section>
    <!-- 章节练习 -->
    <section class="unitPractice">
        <h3>&lt;章节练习二&gt;</h3>
        <p>根据以下结构的HTML代码，实现下列需求：</p>
		<pre>
&lt;div id="skillList"&gt;
	&lt;div data-color="#d98e00"&gt;HTML&lt;/div&gt;
	&lt;div data-color="#0096d9"&gt;CSS&lt;/div&gt;
	&lt;div data-color="#00c72e"&gt;JavaScript&lt;/div&gt;
&lt;/div&gt;
&lt;div id="showInfo"&gt;&lt;/div&gt;
		</pre>
   		<p>1、点击“HTML”、“CSS”或“JavaScript”后在&lt;div id="showInfo"&gt;&lt;/div&gt;内显示出当前标签内的文本；</p>
   		<p>2、在点击这些标签的同时，也要将这些标签内的属性“data-color”所对应的颜色作为&lt;div id="showInfo"&gt;&lt;/div&gt;的背景色；</p>
   		<p>3、&lt;div id="showInfo"&gt;&lt;/div&gt;的字体颜色为白色；</p>
   		<p>4、点击事件由循环进行绑定，点击事件内只有一个带有参数的被调用函数，不能出现其它代码</p>
   		<p>&lt;代码提示&gt;</p>
   		<p>1、获取当前元素节点属性的语法为：Element.getAttribute("HTML标签属性");</p>
   		<p>2、设置当前元素节点背景色的语法为：Element.style.backgroundColor = "颜色";</p>
    </section>
    <!-- 闭包 -->
    <section>
    	<h3>闭包</h3>
    	<p><em>闭包</em>是JavaScript中特有的“作用域链”的产物，也可以说“闭包”本身就是JavaScript的一个特色。何为“闭包”？简单地讲，就是在函数内部再定义一个函数。这样就可以让函数内部的函数可以不经参数直接地访问，并且可以直接地修改其父级（可以是多层）的变量，甚至是函数名（不过通常没有必要这样做）。</p>
    	<p>闭包的结构其实我们在上一节“函数的作用域”中就已经看到了，就是那个设置颜色的函数和之后的两张函数作用域的示例图，它们都是闭包的一种体现。通过示例可以分析出，闭包的本质就是将函数内部和函数外部连接起来的一座桥梁。</p>
    	<p>闭包从编码角度上讲，主要有两种用途：一个是可以读取整个父级作用域函数内部的变量，另一个就是让这些变量的值始终保持在内存中。第一个用途我们之前已经做过示例演示，不难理解。第二个用途我们通过这样一段代码来理解：</p>
    	<code class="indent">
            <img src="img/code/jscode/code-js-313.jpg">
        </code>
        <p>在控制台多次调用实例化后的函数：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-314.jpg">
        </code>
        <p>通过示例可以发现函数每次运行的“count”的计算结果都会在原来的基础上每次都加“10”。通过之前函数的学习我们应该了解，函数在每次运行完成之后，其所在的作用域内的变量会立即销毁，若再次运行函数，内部的变量会被从新被声明，其值也会回归第一次声明时的值。为了证明这一点，我们按照上面的结构从新再实例化一个“非闭包”的函数出来，观察运行的结果：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-315.jpg">
        </code>
        <p>在控制台多次调用实例化后的函数：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-316.jpg">
        </code>
        <p>通过和这次测试的结果可以发现，之前闭包函数的运行和函数被实例化并没有关系，说明闭包函数的确有将值存储于内存的作用，也就是说上例闭包函数中的变量“count”在运行后并没有销毁。这也一方面使得闭包函数可以去实现一些高级的功能，另一方面要考虑到闭包不会被垃圾收集机制回收，大量的运用可能会存在性能问题。</p>
        <p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。如将当前变量的值设置为“<em>null</em>”，将变量的引用解除，当垃圾回收启动时，会自动对这些值为“null”的变量回收。将上面的闭包示例稍微修改一下来减少对内存的消耗：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-317.jpg">
        </code>
    </section>
    <!-- 创建函数对象 -->
    <section>
    	<h3>创建函数对象</h3>
    	<p>函数（function）作为JavaScript的一个主要内置对象（即本身就是一个对象，通过Object(function) === function进行判定），也是创建对象的主要手段之一（另外还包含字面量“{}”形式和构造函数“new Object()”的形式）。</p>
    	<p>我们来看一个使用函数来创建一个对象的示例：</p>
    	<code class="indent">
            <img src="img/code/jscode/code-js-318.jpg">
        </code>
        <p>然后我们就可以像访问普通对象一样去访问实例化出来的对象的属性值了：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-319.jpg">
        </code>
        <p>在构造函数“OriginObject”内部的“this”指向的是实例化后的对象，也就是说在构造函数内部的this指向不是固定的，它会随着实例化对象的不同而指向不同的对象。</p>
        <p>和字面量的形式相比，采用构造函数实例化对象的方式虽然并没有那么直观，但更适合批量创建对象。也就是说当需要创建的对象数量比较大的时候采用这种构造函数的形式会使得代码更佳得简洁。我们只要稍微增加一下对象的数量，就可以清晰地对比出来。</p>
        <p>用构造函数实例化的对象：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-320.jpg">
        </code>
        <p>用字面量创建的对象：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-321.jpg">
        </code>
        <p>通过数数可以看出，用构造函数在创建5个具有3个属性的对象时用了15行代码，而采用字面量的形式使用了25行代码，而且这个差距还会随着对象和属性的增多而继续拉大。这也从实践上证实了我们之前的描述。</p>
    </section>
    <!-- 章节练习 -->
    <section class="unitPractice">
        <h3>&lt;章节练习三&gt;</h3>
        <p>采用构造函数实例化对象的形式创建出3个对象，具体要求如下：</p>
        <p>1、对象包含4个属性和1个方法，基本属性是：“编号”、“姓名”、“性别”和“手机号”。方法是：“修改手机号”；</p>
        <p>2、方法“修改手机号”包含一个参数，用于接受新手机号的字符串，当该方法被调用时可以修改手机号；</p>
        <p>3、为对象原型链上添加一个“显示完整信息”的方法，方法在被调用时将该对象的完整的信息显示出来，格式如：“编号：web0001，姓名：倒霉熊，性别：男，手机号：18213141314”;</p>
        <p>4、属性名和方法名自定，但名称应当尽量能反应当前属性或方法的作用。</p>
    </section>
</root>






