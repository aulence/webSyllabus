<root data-root="JavaScript DOM">
    <!-- 概述 -->
    <section class="mt0">
    	<h3>JavaScript DOM概述</h3>
    	<p>DOM是JavaScript操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个JavaScript对象，从而可以用脚本进行各种操作（比如增删标签和操作属性等），它现在由W3C组织负责维护和进行标准制定。</p>
    	<p>浏览器会根据DOM模型，将结构化文档（比如HTML和XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。所以，DOM可以理解成网页的编程接口。DOM有自己的国际标准，目前的通用版本是DOM 3，而DOM 4已经在2015年11月19日发布了“正式推荐标准”。</p>
    	<p>严格地说，DOM不属于JavaScript，但是操作DOM是JavaScript最常见的任务，而JavaScript也是最常用于DOM操作的语言。DOM的最小组成单位叫做节点。文档的树形结构，就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是DOM。</p>
	</section>

	<!-- DOM节点查询 -->
	<section>
		<h3>DOM节点查询</h3>
		<p>对于DOM的查询，document提供了以下方法：</p>
		<dl class="attrExplain">
			<dt>document.getElementById()</dt>
			<dd>这个方法我们应该是再熟悉不过了，它会返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。</dd>

			<dt>document.getElementsByTagName()</dt>
			<dd>该方法返回所有指定HTML标签的元素，返回值是一个类似数组的HTMLCollection实例对象集合，可以实时反应HTML文档的变化。</dd>
			<dd>如果没有任何匹配的元素，就返回一个空的类似数组。</dd>

			<dt>document.getElementsByClassName()</dt>
			<dd>该方法同样返回一个类似数组的HTMLCollection实例对象集合，包括了所有class名字符合指定条件的元素，元素的变化实时反应在返回结果中。需要注意该方法是在DOM3后新增的标准方法，在IE8及以下版本的浏览器中是不支持的，如果项目需要兼容它们，请使用其他DOM节点的查询方法。</dd>
			<dd>如果没有任何匹配的元素，也会返回一个空的类似数组。</dd>

			<dt>document.getElementsByName()</dt>
			<dd>该方法用于选择拥有name属性的HTML元素，返回一个类似数组的的NodeList实例对象，因为name属性相同的元素可能不止一个。</dd>
			<dd>如果没有任何匹配的元素，还是会返回一个空的类似数组。</dd>

			<dt>document.querySelector()，</dt>
			<dd>该方法接受一个CSS选择器作为参数，返回匹配该选择器的元素节点。如果有一个或多个节点对象满足匹配条件，也只会返回第一个匹配的节点对象。如果没有发现匹配的节点，则返回null。</dd>
			<dd>完整的代码示例如下：</dd>
			<dd>
				<code>
					<img src="img/code/jscode/code-js-444.jpg">
				</code>
			</dd>
			<h4><a href="html-pages/javascript/codeEffect/code-037.html" target="_blank">运行效果</a>：</h4>
			<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-037.html"></iframe>
			
			<dt>document.querySelectorAll()</dt>
			<dd>该方法与querySelector()用法类似，区别是返回一个NodeList对象集合，包含所有匹配给定选择器的节点。</dd>
			<dd>完整的代码示例如下：</dd>
			<dd>
				<code>
					<img src="img/code/jscode/code-js-445.jpg">
				</code>
			</dd>
			<h4><a href="html-pages/javascript/codeEffect/code-038.html" target="_blank">运行效果</a>：</h4>
			<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-038.html"></iframe>
			<dd>这里需要注意的是，使用querySelectorAll()方法后，代码中所有的查询结果都需要加上下标索引，哪怕本来就是唯一的ID查询，否则浏览器都会报错。</dd>
			<dd>还需要注意的是，querySelector()和querySelectorAll()这两个方法虽然都支持复杂的CSS选择器（包括CSS3新增的高级选择器）。但是，它们不支持CSS伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。另外，值得高兴的是，据<a href="http://www.runoob.com/jsref/met-document-queryselector.html" target="_blank">资料显示</a>这两个方法是支持IE8及以上版本的，但需要注意的是，对于IE8本身就不支持的CSS3选择器，还是不能够使用，这点可以到CSS和JavaScript支持情况最权威的网站<a href="http://caniuse.com/#feat=queryselector" target="_blank">Can I Use</a>上进行查询。</dd>

			<dt>Element.closest()</dt>
			<dd>该方法返回当前元素节点的最接近匹配结果的父元素（或者当前节点本身），条件是必须匹配给定的CSS选择器（可以是CSS3高级选择器），不设置参数会报错。如果不满足匹配，则返回null。它的使用方式和querySelector()方法是一样的，仍然支持链式使用。</dd>
			<dd>CSS的代码如下：</dd>
			<dd>
				<code>
					<img src="img/code/jscode/code-js-446.jpg">
				</code>
			</dd>
			<dd>HTML和JavaScript代码如下：</dd>
			<dd>
				<code>
					<img src="img/code/jscode/code-js-447.jpg">
				</code>
			</dd>
			<h4><a href="html-pages/javascript/codeEffect/code-039.html" target="_blank">运行效果</a>：</h4>
			<iframe data-iframe-coderun class="codeEffect" src="html-pages/javascript/codeEffect/code-039.html"></iframe>
		</dl>
		<p>对于本节所有的查询方法来讲，都不能直接对返回结果为一个类似数组（任何类型的集合）的对象去绑定事件，而只能对其中某项绑定事件（在其后添加下标索引），哪怕返回的集合中只有一个元素，否则浏览器都会报出“TypeError”的错误。所以需要去区分总结哪些方法返回的是一个元素/节点对象，哪些方法返回的又是一个集合（主要包括HTMLCollection和NodeList）。</p>
	</section>

	<!-- DOM事件触发 -->
	<!-- <section>
		<h3>DOM事件触发</h3>
		
	</section> -->

	<!-- 属性的操作 -->
	<section>
		<h3>属性的操作</h3>
		<p>对于一个HTML标签可能会有一个或者多个的属性，这些属性都是可以操作的，JavaScript对操作属性提供了以下方法：</p>
		<dl class="attrExplain">
			<dt>Element.getAttribute()</dt>
			<dd>该方法返回当前元素节点的指定属性。如果指定属性不存在，则返回null。参数为指定的属性名称。</dd>

			<dt>Element.setAttribute()</dt>
			<dd>该方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。该方法含有两个参数，第一个参数表示属性名，第二个参数表示需要对属性设置的值。</dd>

			<dt>Element.hasAttribute()</dt>
			<dd>该方法返回一个布尔值，表示当前元素节点是否包含指定属性。参数为指定的属性名称。</dd>

			<dt>Element.removeAttribute()</dt>
			<dd>该方法用于从当前元素节点移除属性。</dd>

			<dt>dataset属性</dt>
			<dd>dataset属性用于获取或设置用户自定义的属性名（data-*），该属性设置属性名和setAttribute()方法不同，它是通过赋值的方式实现的（因为它是一个属性，而非方法）。</dd>
		</dl>
	</section>

	<!-- HTML元素对象 -->
	<section>
		<h3>Element节点对象</h3>
		<p>Element对象实际上是一个构造函数的实例化对象，该对象包含了一系列的属性和方法来返回或设置当前对象指向元素的相关信息。</p>
		<dl class="attrExplain">
			<dt>Element.attributes</dt>
			<dd>该属性返回当前元素所有属性节点的一个类似数组对象。</dd>

			<dt>Element.id</dt>
			<dd>该属性返回指定元素的id属性，是一个可读可写的属性。</dd>

			<dt>Element.tagName</dt>
			<dd>该属性返回指定元素的大写标签名，与nodeName属性的值相等。但在<em>事件对象</em>（event）上通常使用tagName更加常见。</dd>

			<dt>Element.innerHTML</dt>
			<dd>属性返回该元素包含的HTML代码。该属性可读可写，常用来设置某个Element节点的内容。如果将该属性设为空字符串，等于删除了它包含的所有节点。</dd>

			<dt>Element.outerHTML</dt>
			<dd>该属性返回一个字符串，内容为指定元素节点的所有HTML代码，包括它自身和包含的所有子元素。该属性是同样是可读可写的，对它进行赋值，等于替换掉当前元素。</dd>
			<dd>但是如果该Element节点已经被赋值给一个变量了，在使用outerHTML替换原来的标签后，之前的变量值还是能够访问，也就是说被替换掉的内容依然保存于内存。</dd>

			<dt>Element.match()</dt>
			<dd>该方法用于匹配当前的Element节点是否匹配方法参数内的CSS选择器字符串，和querySelector()和querySelectorAll()的参数一样，CSS选择器必须是完整的选择符（如id前需要加上“#”，class前面要加上“.”，属性选择器要用“[]”括起来等）。它返回的是一个布尔值。</dd>

			<dt>Element.insertAdjacentHTML()</dt>
			<dd>该方法解析HTML字符串，然后将生成的节点插入DOM树的指定位置。该方法带有两个参数，第一个参数表示插入位置，第二个参数表示插入的字符串（可以是HTML标签）。</dd>
			<dd>第一个插入参数允许的值如下：</dd>
			<dd>
				<ul>
					<li>beforebegin：在当前元素节点的前面。</li>
					<li>afterbegin：在当前元素节点的里面，插在它的第一个子元素之前。</li>
					<li>beforeend：在当前元素节点的里面，插在它的最后一个子元素之后。</li>
					<li>afterend：在当前元素节点的后面。</li>
				</ul>
			</dd>

			<dt>Element.scrollIntoView()</dt>
			<dd>该方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。</dd>
			<dd>该方法可以接受一个布尔值作为参数。如果为true，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为false，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为true。</dd>

			<dt>Element.focus()</dt>
			<dd>该方法可以上元素获得焦点。用户使用键盘Tab键可以切换获得焦点的元素，都可以使用该方法来获得焦点。</dd>

			<dt>Element.remove()</dt>
			<dd>该方法用于删除当前的子节点，并且不再存在于DOM树内和内存里。</dd>
		</dl>
	</section>
	
	<!-- style对象 -->
	<section>
		<h3>style对象</h3>
		<p>每一个网页元素对应一个DOM节点对象。这个对象的style属性可以直接操作，用来读写行内CSS样式。style对象的属性值都是字符串，设置时必须包括单位，但是不含规则结尾的分号。比如，divStyle.width不能写为100，而要写为100px。</p>
		<p>style对象的<em>cssText</em>属性属性允许直接以字符串的形式来设置一个元素的样式，可以设置一个样式，也可以是多个，其语法与CSS文件选择器内部的语法完全一致。</p>
		<p>另外，我们还可以使用“document.body.style.CSS样式属性名”或“document.body.style["CSS样式属性名"]”的方式来检测当前的浏览器是否支持某一CSS样式，只要返回的值是一个非undefined的值，就说明当前浏览器是支持该CSS样式的。</p>
		<p>此外，部分浏览器（Firefox 22+, Chrome 28+, Opera 12.1+）目前部署了supports API，可以返回一个布尔值，表示是否支持某条CSS规则。但是，这个API还没有成为标准。语法如下：</p>
		<p><em>CSS.supports("属性名", "属性值")</em> 或 <em>CSS.supports("(属性名1: 属性值2) and (属性名1: 属性值2)")</em></p>
		<p>除此之外，如果想获取一个元素的CSS样式（不是标签上的style属性）属性的值，则可以使用window对象下的<em>getComputedStyle()</em>方法，通过访问该方法下指定的CSS属性名来获得属性值。该方法获取的CSS内容不一定是CSS文件里明文自定义的属性，也可以是默认状态的属性。</p>
		<p>该方法带有两个参数，第一个参数为需要获取CSS属性值的Element对象，第二个参数为伪类（如“:after”），如果不需要判断伪类，可以将其设置为null。语法格式如下：</p>
		<p><em>getComputedStyle(Element, Pseudo-classes).CSS属性名;</em></p>
	</section>

	<!-- class属性的操作 -->
	<section>
		<h3>Class属性的操作</h3>
		<p>每个Element节点对象都具有两个关于Class的属性：“Element.className”和“Element.classList”。className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割。classList属性则返回一个类似数组的对象，当前元素节点的每个class就是这个对象的一个成员。</p>
		<p>classList对象有下列方法：</p>
		<ul class="indent">
			<li>add()：增加一个class。</li>
			<li>remove()：移除一个class。</li>
			<li>contains()：检查当前元素是否包含某个class。</li>
			<li>toggle()：将某个class移入或移出当前元素。</li>
			<li>item()：返回指定索引位置的class。</li>
			<li>toString()：将class的列表转为字符串。</li>
		</ul>
	</section>
</root>






