<root data-root="JavaScript对象">
    <!-- 对象概述 -->
    <section class="mt0">
        <h3>对象概述</h3>
        <p>对象（object）是JavaScript的核心概念，也是最重要的数据类型。JavaScript的所有数据都可以被视为对象。简单说，所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value，亦称属性名值对、成员等）构成。下面展示了两种对象的书写方法：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-148.jpg">
        </code>
        <p>两种写法的引号可为双引号，也可以为单引号。若有多个键值对，每个键值对后面都需要加上英文逗号“,”作为分割符，否则程序会报错，最后一个键值对后方可加，也可不加。第一种写法为常用写法，是程序中最常用的写法，第二种写法叫做严格写法，这种严格模式的写法通常用于<em>JSON</em>文件的编写。但实际上第二种写法在某些情况下是一种必要手段，就是当属性名（键名）为数字外加其它内容等一些非严格命名模式的时候。如果为数字（包括科学计数法、浮点数、进制数），数字会被自动转换成字符串，如果是出现数字+其它字母、字母+空格+字母、字母+其它符号等的时候，就必须要手动加上引号了，否则程序会报错。 </p>
        <code class="indent">
            <img src="img/code/jscode/code-js-149.jpg">
        </code>
        <p>其实哪怕就是从我们编辑器（示例采用编辑器为“Adobe Brackets”）的代码颜色来看，第二种写法也明显不符合语法规范，键名出现了颜色不正常的现象，放置于控制台运行，可以更加清晰地看到运行的结果。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-150.jpg">
        </code>
        <p>另外，JavaScript内的关键字和保留字也可以作为属性名，并且不需要加上引号也能正常使用。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-151.jpg">
        </code>
	</section>
    <section>
    	<h3>对象的属性值类型</h3>
        <p>对象允许的值可以是JavaScript种的任何类型（6种类型），可以是一个表达式，也可以为一个函数，当一个属性的值为一个函数的时候，通常把这个对象的属性称作“<em>方法</em>”（如操作字符串或数组的各种方法），它可以像使用其它对象内的属性一样使用，但是需要在后方加上一对括号。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-152.jpg">
        </code>
        <p>定义了这样一个包含了各种类型数据的对象之后，就可以在程序中使用了（作用域仍然只分全局和函数的作用域）。为了直观展现运行结果，我们依次对上面定义的这个对象的各个属性在控制台运行程序后进行访问或使用。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-153.jpg">
        </code>
        <p>可以发现，我们现在对象中定义属性直接可以被像一个变量一样使用了，只不过是使用的时候多了一个点“.”，将普通变量的“=”号换成了“:”号而已，除此之外基本没有任何不同。</p>
	</section>
    <section>
    	<h3>对象的赋值</h3>
        <p>作为数组形式展现的对象一样，普通对象也可以先声明再设置属性。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-154.jpg">
        </code>
        <p>根据对象的这个特性，我们就可以根据当前的使用场景（如满足一定的条件语句后），动态地为对象添加需要的属性了。但需要注意的是，对象数据类型是引用型数据，也就是说当一个对象赋值给另外一个变量后，它们指向的内存地址是相同的（这和数组一样），如例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-155.jpg">
        </code>
        <p>但是有一点需要注意，也就是任何一个对象取消对值的引用，之前已经引用过该值的对象是的值仍旧会保留。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-156.jpg">
        </code>
	</section>
    <section>
    	<h3>对象属性值读取的两种方式</h3>
        <p>对于对象属性的读取，主要有两种方式，一种是“对象.属性”的格式，另一种是“对象[属性]”的格式。但是这两种方法在有些情况下并非等价的，就是如果属性是<em>数值型</em>的话不能采用第一种加“.”的形式，只能写成第二种形式。如果属性是<em>字符串</em>的话，两种形式都可以使用，但是使用第二种的话需要再在方括号内加上一对引号，否则会被视作一个变量。正确示例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-157.jpg">
        </code>
        <p>错误示例：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-158.jpg">
        </code>
        <p>这两种访问属性的方法的区别还不止于此，通过“.”访问的属性不能是变量，不能是运算表达式，但是用“[attr]”这种方式可以接受变量，亦可以接受运算表达式。在对象的属性不是很确定的时候，用“[variable]”作为一个对象的载体是一个非常不错的选择。</p>
        <p>比如现在，我们在一个虚拟出来的“书籍”对象内配置一个简单的方法，用于输出一个对象内指定属性的值，就可以这样去写：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-159.jpg">
        </code>
        <p>在控制台中进行传参调用后的结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-160.jpg">
        </code>
        <p>如果讲上例中的“book[link]”换成“book.link”的话，该功能是无法完成的，无论配置任何参数返回的都将是undefined。正是因为使用“[]”的形式有接收变量的作用，这为我们以后封装具有对象的函数提供了便利。但若所使用对象不涉及到变量，还是建议使用“.”的形式对属性访问更加便捷高效。</p>
        <p>看完上面的示例后，请自己做一个试验，将“book”这个对象仿照的写一遍，然后将对象内的“showInfo()”这个方法内的“book”一词改为“this”，然后传递对象内其它的属性名的字符串作为参数调用该方法，观察是什么样的结果。</p>
        <p>对于使用“[]”访问对象的属性还有一点需要补充，就是若对象是一个数组的话还可以使用<em>运算表达式</em>去访问数组内的内容。这对于实现一些复杂的需求会有一定程度的帮助，我们看来这几个简单例子：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-161.jpg">
        </code>
        <p>示例中最后三个完全一样的表达式“arr[Math.round(Math.random() * (arr.length - 1))]”得出的结果却不相同，是因为里面用到了<em>Math</em>函数内的取0~1之间的随机数方法<em>random()</em>，外层用该函数的“四舍五入”方法<em>round()</em>保证取出的数是整数。整个“[]”取出的数为整个数组下标从0到length-1（最大下标）之间的随机下标。</p>
	</section>
    <section>
    	<h3>属性名数组Object.keys()</h3>
        <p>和查看所有数组的下标一样，利用<em>Object.keys(obj)</em>方法可以查看对象所有的属性名，返回的结果是一个数组。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-162.jpg">
        </code>
        <p>通过上面的示例可以发现，利用这个内置对象Object的keys()方法，我们可以“玩出”非常多的花样，不仅可以像数组那样通过“length”属性（对象本身是没有length这个属性的）获取到对象的属性个数，还可以像数组那样，通过下标去访问对象内的属性值。单是获取对象属性个数这一点来讲，这个方法会被我们用“计数器”+“for-in遍历”要显得“干净”得多。</p>
        <p>现在我们通过在对象的原型链上添加一个“eq()”方法来模仿像<em>jQuery</em>那样通过“eq(index)”方法（方法内的“index”表示对象下标）来访问jQuery对象的指定元素。仍旧采用上面的“book”对象进行演示：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-296.jpg">
        </code>
        <p>通过示例可以发现，现在的对象已经可以使用下标进行访问了，再加上通过Object.keys()方法本身就可以间接去获取对象的属性个数（获取到属性名集合的长度属性），这就使得通过普通的循环语句（非for-in语句）来遍历一个对象成为了可能。</p>
	</section>
	<!-- 章节练习 -->
    <section class="unitPractice">
        <h3>&lt;章节练习一&gt;</h3>
        <p>声明一个名为“roleInfo”的对象：</p>
        <ol>
            <li>属性名分别为：id、name、attack、defense、speed、hp、mp、skill</li>
            <li>值分别是："lol-119"、"德玛西亚之力"、36、42、66、2400、null、["坚韧（被动）","致命打击","勇气","审判","德玛西亚正义"]</li>
            <li>通过在原型链上添加一个“attrVal()”方法，然后通过Object.keys()方法来获取对象的“长度”，最后通过for循环将对象内的所有值输出在页面内一个id为“galen”的&lt;div&gt;里</li>
            <li>字段通过这个数组 ["ID","角色名","攻击力","防御力","速度","血量","魔法","技能"] 在循环结构内进行输出</li>
        </ol>
        <p>&lt;注意&gt;若值为“null”，在页面内应该显示为“无”，若值为一个数组（通过方法“Array.isArray()”进行判定），需要将转换为字符串输出，而不是输出整个数组，每项之间用空格分隔。另外，需要注意的是初始的HTML内容只有一个ID为“galen”的div标签，标签内不含任何内容。</p>
        <p>最终输出到HTML页面的大致结果如下（需要给每行嵌套上一个div或者p标签分行显示）：</p>
		<pre>
&lt;div id="galen"&gt;
	&lt;label&gt;ID：&lt;/label&gt;&lt;span&gt;lol-119&lt;/span&gt;
	&lt;label&gt;角色名：&lt;/label&gt;&lt;span&gt;德玛西亚之力&lt;/span&gt;
	&lt;label&gt;攻击力：&lt;/label&gt;&lt;span&gt;36&lt;/span&gt;
	&lt;label&gt;防御力：&lt;/label&gt;&lt;span&gt;42&lt;/span&gt;
	&lt;label&gt;速度：&lt;/label&gt;&lt;span&gt;66&lt;/span&gt;
	&lt;label&gt;血量：&lt;/label&gt;&lt;span&gt;2400&lt;/span&gt;
	&lt;label&gt;魔法：&lt;/label&gt;&lt;span&gt;&lt;/span&gt;
	&lt;label&gt;技能：&lt;/label&gt;&lt;span&gt;坚韧（被动）&nbsp;&nbsp;致命打击&nbsp;&nbsp;勇气&nbsp;&nbsp;审判&nbsp;&nbsp;德玛西亚正义&lt;/span&gt;
&lt;/div&gt;
		</pre>
        <p>浏览器显示结果示例图：</p>
        <p>
            <img src="img/content/javascript/object.keys.example.jpg">
        </p>
    </section>
    <section>
    	<h3>对象的“增、删、改、查”</h3>
        <p>对于数据操作来讲，无非就是四种操作“增、删、改、查”。对于对象来讲，“增”就是为一个对象新增一个之前不存在的属性名，然后进行赋值；“改”就是对对象已经存在的属性名进行从新赋值，达到一个修改原始对象的效果；而“查”就是简单地通过对象的属性名访问即可（当然也可以通过对“[]”传变量实现访问）。这些我们之前都讲解过，但对于“<em>删</em>”来讲稍微有些特殊，需要用到关键字“<em>delete</em>”进行操作，为了说明问题，我们还是对这些操作进行回顾并在其中列出“delete”的使用方式。原数组如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-163.jpg">
        </code>
        <dl class="attrExplain">
            <dt>增</dt>
            <dd>新增一个“出版社”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-164.jpg">
                </code>
            </dd>

            <dt>删</dt>
            <dd>删除“出版装订类型”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-165.jpg">
                </code>
            </dd>
            <dd>注意，该方法在执行成功后会返回一个布尔值<em>true</em>，只有当正在删除的对象属性不存在或不能删除（如继承的属性：toString、valueOf等）时才会返回false值。</dd>

            <dt>改</dt>
            <dd>修改“图书页数”和“出版时间”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-166.jpg">
                </code>
            </dd>

            <dt>查</dt>
            <dd>查询“书名”、“作者”和“页数”属性。</dd>
            <dd>
                <code>
                    <img src="img/code/jscode/code-js-167.jpg">
                </code>
            </dd>
        </dl>
	</section>
    <section>
        <h3>判断一个属性是否存在于对象</h3>
        <p>当不知一个对象的属性是否声明过（或不知某个属性是否存在于指定的对象内），使用“<em>in</em>”运算符来进行判断是再好不过的选择了（选用对象仍是之前的“书籍”）。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-168.jpg">
        </code>
        <p>in运算符返回一个布尔值，它不区分该属性是对象自身的属性，还是继承的属性。若要区分该属性是实例化对象的属性，还是继承而来的属性需要使用“hasOwnProperty()”方法，该方法返回的仍然是一个布尔值。例如现在我们先给对象原型链添加一个属性，并创建一个对象：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-297.jpg">
        </code>
        <p>然后在控制台中输出所有的属性值，然后再通过该方法进行判断：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-298.jpg">
        </code>
        <p>通过观察示例可以发现，虽然无论是对象本身的属性还是继承而来的属性都可以正常输出结果值，但是区别在于本来存在于对象中的属性“brand”和“price”通过hasOwnProperty()方法判断后返回的布尔值是true，而通过对象的原型链继承而来的属性“effect”执行方法后返回的布尔值为false。</p>
        <p>这样一来，我们就可以在执行for-in遍历语句的时候决定是否应该对继承而来的属性进行指定的操作了。</p>
    </section>
    <!-- 章节练习 -->
    <section class="unitPractice">
        <h3>&lt;章节练习二&gt;</h3>
        <p>模仿上例，为对象原型链添加一个方法，并自定义一个对象：</p>
        <p>1、通过for-in遍历语句在控制内输出对象的全部属性的值；</p>
        <p>2、通过for-in遍历语句在控制内输出对象的非继承属性的值。</p>
    </section>
    <!-- 对象操作 -->
    <section>
        <h3>对象的原型链</h3>
        <p>JavaScript原生提供一个Object对象，所有其他对象都继承自这个对象。Object本身也是一个构造函数，可以直接通过它来生成新对象。基本语法为：</p>
        <p><em>var obj = new Object();</em></p>
        <p>JavaScript的数据有一个比较有趣的特点就是它具有<em>原型链</em>（prototype，也有称“原型类”），任何数据对象都能通过原型链来拓展自己的功能，每个数据类型都可以通过为原型链添加属性或方法来扩展自身的功能。Object的原型链的扩展会成为所有数据类型的通用方法，这是因为在JavaScript中，所有的数据类型都是Object的继承。我们来看一个关于内置对象通过原型链扩展自己的<em>方法</em>的简单例子，基本代码如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-169.jpg">
        </code>
        <p>在控制台中被调用后的返回值结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-170.jpg">
        </code>
        <p>上面的代码中，首先是给内置对象Object添加了一个原型链的方法，该方法内“keys()”方法的作用我们在之前的一节中已经学习过，它是用于将对象的属性名进行返回，然后形成一个数组。而在该方法之前有一个关键字<em>this</em>，它表示使用该原型方法的对象的本身，如obj1在使用showAttr()方法时，this指的就是obj1，obj2调用这个方法，那this指的就是obj2，以此类推。</p>
        <p>showAttr()这个方法是我们的一个自定义名称，我们可以根据需要，给原型链添加任意的自定义方法。这样一来，以后所有新建的数据对象都可以使用这些方法，大大地减少了代码量和也减少了对方法参数的配置。可以把原型链内我们自定义新建的方法理解为对象的公共方法，任何类型数据对象在同一个作用域内都可以对其进行使用。</p>
	</section>
    <section>
        <h3>内置对象</h3>
        <p>其实，也并非只有数组（Array）和普通对象（Object）才是所谓的“对象”，可以将JavaScript任何允许的数据类型放置于<em>Object()</em>方法的参数内都可以转换成为一个对象，这样的对象称作“<em title="变量的赋值操作是对值的引用">包装对象</em>”，这在我们上一章的课程里已经见过了。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-171.jpg">
        </code>
        <p>但如果使用Object()方法为参数内配置一个数据，或该数据的变量，如果返回的是该数据本身的值，那我们将其称作“<em title="变量的赋值操作是对内存地址的引用">内置对象</em>”。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-172.jpg">
        </code>
        <p>为了证明这一点，我们对刚才的这些内置对象做了一次“严格等于”运算符的比较运算。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-173.jpg">
        </code>
        <p>像“对象”这种复合型的值，通过普通方式来判断它是否为一个“内置对象”比较困难，像判断数值和判断数组都有类似于“isNaN()”和“isArray()”这样的方法，但是对象却没有，直接使用我们猜测存在的方法“isObject()”只会是这种下场：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-174.jpg">
        </code>
        <p>但好消息是，这并不妨碍我们自己根据对象已经暴露的一些特性给它创建一个判断数据类型的方法：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-175.jpg">
        </code>
        <p>调用我们自定义的原型链方法后，在控制台中的返回值结果分别如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-176.jpg">
        </code>
        <p>这样一来，就可以通过我们给对象原型链新增的这个isObject()方法来判断一个操作数或变量是否为一个“内置对象”了。</p>
        <p>上面的自定义方法，是将需要判定对象类型的变量放置于参数内，思考一下若需要将变量或对应的数据放置于方法之前作为一个对象的操作形式应该这么做（即：obj.isObject()的格式，注意当数据作为对象的形式来操作时，若是一个非内置对象，则会被自动“包装”）。</p>
	</section>
    <section>
        <h3>数据类型的精确判定</h3>
        <p>上一章我们在讲解“字符串操作”的时候提到过一个方法“<em>String()</em>”，它可以将任何类型的数据都转换成字符串，但在转换数组和对象时，出现了点特殊情况（可以自行回顾该章节的内容），即其它类型的数据都变成了和原始声明时基本一样的数据，只是加上了引号，而对象出现的结果却是“<em>[object Object]</em>”，其实这里的第一个值表示该值是一个对象（之前提到过，JavaScript中任何值都可以成为对象），第二个值为该类型值的构造函数（有些对象是通过包装而来的）。当然，除了将需要转换字符串的内容放置于String()方法的参数内，还能通过对象属性的方式来使用该方法，它的写法是“toString()”，不需要配置参数。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-177.jpg">
        </code>
        <p>可以从运行结果中看出来，这和我们上次使用的“String()”方法得出的结果完全一样。但其实作为一个对象的属性的“toString()”方法来讲自然会有一些不同的。它其实是对象原型链的一个方法，语法如下：</p>
        <p><em>Object.prototype.toString</em></p>
        <p>既然是原型链的方法，那很多时候它们还有自己的“<em title="内部的实现相当于一个函数闭包">子方法</em>”，如“<em>call()</em>”方法。基本使用方法如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-178.jpg">
        </code>
        <p>通过示例可以发现，除了特殊的自身不等于自身的“NaN”值以外，其它的值都在返回结果的第二个值中表现出了自己真实的“值类型”，这最大程度地弥补了“typeof()”方法（通常情况下，typeof()方法还是首选）的不足。但是单是发现了这个原型方法的特性还没有什么用，要真正地将该特性利用起来，还得我们自己写成一个方法函数。</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-179.jpg">
        </code>
        <p>通过在控制台中调用该函数进行测试：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-180.jpg">
        </code>
        <p>经过简单测试，自定义的方法完美地实现了数组类型的精确判定。</p>
        <p>在这里需要说明一下call()方法在这里扮演的“角色”，call()方法是用于绑定对象内部“this”关键字的指向，因为this在非事件执行的情况下，或没有被实例化为一个对象的函数内都是是默认指向window这个对象的。我们来看一个这样的例子来证明这一点，并说明call()在这里的作用：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-299.jpg">
        </code>
        <p>在控制台调用函数对象的call()方法后的结果如下：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-300.jpg">
        </code>
        <p>为什么会出现这样的执行结果呢，我们再来看一个这样的小测试：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-301.jpg">
        </code>
        <p>可以发现，window是一个当前全局环境里的“<em>根对象</em>”，所有设置在全局里的变量都是它的属性，所以我们可以通过以上形式对设置在全局内的变量进行访问。通过这一点，我们再去联系之前示例的运行结果应该更好理解。就是当call()方法的参数是一些非指定变量名的时候，或window对象的时候，函数testCall()内的this都是指向全局内的“name”变量的，而当call()方法内的参数为全局下的对象“obj”的时候，this指向的就是“obj”了，通过运行函数，返回的值相当于是“obj.name”了。</p>
        <p>明白了这些特性后，我们还可以发挥自己的想象能力玩一些更为“高端的操作”，如：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-181.jpg">
        </code>
        <p>通过在控制台中调用自定义的对象的方法进行测试：</p>
        <code class="indent">
            <img src="img/code/jscode/code-js-182.jpg">
        </code>
    </section>
    <!-- 章节练习 -->
    <section class="unitPractice">
        <h3>&lt;章节练习三&gt;</h3>
        <p>通过已经学习过的方法完成以下数组和对象的“克隆”，克隆后的数组和对象的值发生改变后，对原数组和对象的值不产生影响：</p>
        <p>1、数组：["HTML","CSS","JavaScript"]；</p>
        <p>2、对象：{name: "JS", fullName: "JavaScript", duty: "行为控制"}；</p>
        <p>3、实现一个自定义的方法用于判定一个变量是否是一个内置对象，需要使用“data.isBuiltinObject()”的形式，其中data为你需要判断的数据。</p>
    </section>
</root>






